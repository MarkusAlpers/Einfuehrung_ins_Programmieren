\chapter{Einstieg in HTML 5}

Dass Sie in diesem Kapitel die Grundlagen der Programmierung in HTML5 erlernen ist nach der Kapitelüberschrift klar. Aber Sie werden hier ebenfalls Konzepte kennen lernen, die wichtig sind, damit Ihre Seite tatsächlich ein Teil des semantic web ist. Dieses Kapitel ist auch für komplette Neueinsteiger in die Programmierung leicht zu bearbeiten, da Sie hier nur wenige abstrakte Grundlagen verinnerlichen müssen, die sonst in der Welt der Informatik und der Programmierung recht häufig vorkommen.\\

Wenn Sie mit Dateien arbeiten, sind Sie es in aller Regel gewöhnt, die Datei mit einem Programm zu öffnen. Die meisten von Ihnen kennen also nur die verschiedenen Ansichten, die einzelne Programme erzeugen, wenn Sie mit einem dieser Programme eine Datei öffnen. Bei einer Webanwendung sehen Sie beispielsweise verschiedene Elemente wie Bilder, Videos, Texte usw. Sie sehen dann aber in aller Regel nicht, wie diese Datei selbst aussieht. Doch genau darum geht es in diesem Kurs.\\

Wenn Sie das jetzt irritiert, dann machen Sie sich bitte folgendes klar: Wenn Sie eine pdf-Datei öffnen, dann generiert der pdf-Reader eine Ansicht. Das was Sie sehen ist also nicht die Datei selbst, sondern nur eine aus dieser Datei erzeugte Ansicht. Und alles, was Sie irgendwo von einem Computer angezeigt bekommen ist eine Interpretation einer oder mehrerer Dateien. Wenn Sie also lernen wollen, wie Sie Computer programmieren können, dann müssen Sie als erstes verstehen, dass Sie bislang immer nur eine Interpretation dessen gesehen (oder gehört) haben, was tatsächlich \glqq{}auf dem\grqq{} Computer gespeichert ist.\\

In HTML kümmern wir uns dagegen nicht darum, wie eine Webanwendung aussehen soll, sondern ausschließlich darum, aus welchen Bestandteilen die Webanwendung bestehen soll. In anderen Worten: In diesem ganzen Kapitel wird es nicht ein einziges Mal darum gehen, wie die Elemente Ihrer Webanwendung später aussehen werden. Wenn Sie hier also an irgend einer Stelle versuchen, die Darstellung zu programmieren, dann machen Sie einen Fehler.\\

Nachdem wir zuvor weitgehend geklärt haben, wie wir eine Webserver auf unserem Rechner in Betrieb setzen und kontrollieren können, kommen wir nun zum zweiten Teil dieser Einführung: Die Einführung in die Markup Language HTML. Am Ende dieses Abschnittes können Sie also statische Webanwendung erstellen. Danach werden wir über \textbf{CSS}\index{Programmiersprache!CSS}\index{CSS} sprechen: Cascading Style Sheets sind eine Möglichkeit, um auf unterschiedlichen Webanwendung gleiche Strukturen und Formate für Inhalte zu realisieren. Danach kommen wir zur Programmierung in PHP, womit Sie die Elemente Ihrer Webanwendung dynamisch und interaktiv programmieren können.\\

\textbf{Aufgabe}:\\

Unabhängig von dem, was in den einzelnen Abschnitten steht, programmieren Sie bitte für jedes Element, dass Sie auf Ihrer Webanwendung einbinden wollen einen eigenen HTML-Container, ohne sich über das Design Gedanken zu machen. Das ist der erste Schritt hin zu professionellen Anwendungen: So lange Sie es nicht schaffen, zuerst die Inhalte bzw. Inhaltsstruktur festzulegen und erst dann ein passendes Design auszusuchen sind Sie weit davon entfernt, professionelle/r InformatikerIn zu sein. Das bedeutet nicht, dass Design unwichtig wäre, sondern es geht darum, dass Sie sich auf Ihre zukünftige Aufgabe in Teams konzentrieren. Und so lange Sie nicht Design (z.B. Medien- und Kommunikationsdesign) studieren, bereiten Sie sich eben auch nicht darauf vor, als DesignerIn zu arbeiten. So lange Sie das nicht akzeptieren werden Sie ein Don Quichote der Medieninformatik bzw. der Medientechnik sein.\\

Ignorieren Sie also Aspekte wie Design, die Positionierung eines Elements auf der Seite, Hyperlinks, usw. usf. Auch für die einzusetzenden Text, Bilder usw. verwenden Sie bitte vorerst Platzhalter: Die Qualität Ihrer Arbeit als MedieninformatikerIn wird sich nicht in umfangreichen Texten und Bildergallerien zeigen, sondern in gut durchdachten und ausgearbeiteten Strukturen. Das Einfügen von Texten und Bildern sowie das Ausarbeiten eines guten Designs ist dann die Aufgabe anderer Mitarbeiter im Team.

\subsection{Das ist HTML}

\textbf{HTML}\index{HTML}\index{Programmiersprache!HTML}, kurz für Hyper Text Markup Language ist, wie es aus dem Namen hervorgeht eine \textbf{Markup Language}\index{Markup Language}. Teilweise wird auch von einer statischen Skriptsprache gesprochen. Statisch bedeutet hier, dass es mit HTML nicht möglich ist, Inhalte während der Nutzung zu ändern. In der Anfangszeit des \textbf{WWW}\index{WWW} genügte das auch, weil es schon eine großartige Bereicherung darstellte, Texte und Bilder direkt über eine Datenleitung in wenigen Sekunden oder Minuten empfangen zu können, die sonst per Post erst nach einigen Tagen oder Wochen im Haus gewesen wären. \\

Heute dagegen, wo selbst das Format von Displays kaum noch standardisiert ist, benötigen wir weitergehende Möglichkeiten. Diese werden unter dem Begriff \textbf{Responsive Design}\index{Responsive Design} zusammengefasst: Das Design einer Webanwendung passt sich automatisch dem Gerät an, auf dem es angezeigt wird. Wir reden wir hier also über etwas, das in den Bereich der Informatik bzw. der Softwareentwicklung fällt und nicht in den Bereich dessen, was üblicherweise unter Design im Sinne von kreativer Gestaltung verstanden wird.\\

Deshalb muss es hier nochmal betont werden: Wenn Sie HTML programmieren und festlegen, wie ein Element aussieht oder wo es angeordnet werden soll, dann erzeugen Sie damit in den meisten Fällen eine Webanwendung, die auf einer Vielzahl von Nutzergeräten grausig aussehen wird, egal wie gut Ihr Webdesign sonst sein mag. Also lassen Sie das.\\

Dieser Kurs behandelt jedoch nicht die Feinheiten der Usability, zu denen Responsive Design gehört. Vielmehr ist das eine der Spezialisierungen, die MedieninformatikerInnen im Masterstudium wählen können.

\subsection{Erster HTML-Quellcode}

Das wichtigste bei der Programmierung einer Webanwendung ist die Antwort auf die Frage, aus welchen Einheiten sie bestehen soll und welche Funktion jede dieser Einheiten übernehmen soll. Erst danach überlegen Sie sich idealerweise unterstützt durch Designer, mittels welches Designs diese Funktion erkennbar sein soll. Ein typischer Einsteigerfehler besteht darin, sich zunächst über das Design Gedanken zu machen und dann mit dem Programmieren anzufangen. Das ist deshalb ein Fehler, weil dabei in aller Regel wichtige Funktionalitäten vergessen werden oder (noch schlimmer) es für Nutzer nicht erkennbar ist, wie eine Funktionalität genutzt werden kann. Wird dann entdeckt, dass eine Funktionalität fehlt, die wichtig ist, dann muss häufig das Design komplett verworfen und neu entwickelt werden. Oder es herrscht die Überzeugung vor, dass der Kunde schon blöd genug sein wird, sich nicht daran zu stören. Und glauben Sie mir: Bei der Prüfung für Ihre Leistungsnachweise haben Sie keinen naiven Kunden vor sich.\\

Deshalb nun die Frage: Welche Funktion soll unsere erste Webanwendung erfüllen?\\

\textbf{Hinweis}:\\

Diese Webanwendung ist ausschließlich für diejenigen gedacht, die zu Hause dieses Buch durcharbeiten wollen. Das gleiche gilt für \emph{Hausaufgaben} und andere Übungen, die Sie hier finden. Es handelt sich hier nicht um Aufgaben, die Sie für einen Leistungsnachweis in Studienveranstaltungen von mir bearbeiten müssen. Vielmehr können Sie sich so unabhängig von meinen Studienveranstaltungen in das Thema einarbeiten.\\

Beginnen wir mit einer einfachen Seite, mit der wir einfach nur prüfen wollen, ob ein Text so angezeigt wird, dass wir mit der Darstellung zufrieden sind: Er sollte groß genug angezeigt werden, damit wir ihn lesen können. Außerdem sollte er an einer Position angezeigt werden, an der er von einem Nutzer unserer Seite bemerkt wird.\\

Das ist ziemlich viel Text, um daraus eine Prüfung abzuleiten, ob die Funktionalität erfüllt ist. Deshalb gibt es das Planungswerkzeug \textbf{Use Case}\index{Use Case}. Ein Use Case ist eine kurze Beschreibung, wer was mit einer Webanwendung tut und was dann passieren soll. Machen wir das doch gleich für unseren Fall:\\

Use Case 1: Der Nutzer liest einen Begrüßungstext. (Keine Interaktion.)\\

Sicher, das ist kein spannender Use Case, weil er keine Interaktion enthält. Vor allem können wir auch gar nicht prüfen, ob einzelne NutzerInnen\\tatsächlich lesen, was da angezeigt wird. Aber damit können wir arbeiten und nach der Programmierung prüfen, ob die Funktionalität erfüllt ist. Geben Sie den folgenden Quellcode in einen einfachen Editor (z.B. den kostenlosen notepad++) ein und speichern ihn unter dem Namen \verb|seite01.html| im bekannten Verzeichnis Ihres Webservers.

\begin{verbatim}
<html>
<head>
<title>Die erste HTML-Webanwendung</title>
</head>
<body>
Einführung in die Programmierung, Teil 1
</body>
</html>
\end{verbatim}

Gleich vorweg: Willkommensgrüße oder ähnliches haben auf einer Webanwendung nichts verloren. Entweder der Nutzer kann auf Anhieb erkennen, was hier angeboten wird oder wir haben als Entwickler etwas falsch gemacht.\\

Wenn Sie jetzt die Webanwendung aktualisieren (oder bei gestopptem\\Webserver zunächst den Webserver neustarten und anschließend wieder die Webanwendung localhost aufrufen), sehen Sie, dass das neue HTML-Skript als Datei angezeigt wird. Wählen Sie doch einfach den \glqq{}Link\grqq{} an und öffnen Sie damit die Webanwendung, die Sie gerade programmiert haben.\\

Es gibt zwei Dinge, die Ihnen auffallen, wenn Sie das Ergebnis im Browser genau prüfen (zumindest wenn Sie keinen Tippfehler im Quellcode haben): \\

\begin{itemize}
	\item Zum einen steht da nicht das Wort Einführung im Text, sondern so etwas wie EinfÄ3/4rung.
	\item Und dann steht auf der Registerlasche der Webanwendung der Schriftzug \verb|Die erste HTML-Webanwendung|.
\end{itemize}

Wenn Sie die einleitenden Kapitel aufmerksam gelesen haben, dann haben Sie sicher schon eine Idee, warum hier kein \verb|ü| in Einführung steht. Aber dazu gleich mehr. Zuvor schauen wir uns zwei Dinge an. Da wäre einmal die Frage, wie wir möglichst effizient programmieren könenn und dann steht die Frage an, welche Bestandteile unser Quellcode enthält.

\subsubsection{Tags und Container}

Der Schriftzug \verb|Die erste HTML-Webanwendung|, der als Titel der Seite im Webbrowser angezeigt wird, steht zwischen den \glqq{}Befehlen\grqq{} \verb|<title>| und \verb|</title>|. Solche \glqq{}Befehle\grqq{} werden in Markup Languages als Tags bezeichnet. (Aussprache wie tägs und nicht wie tags (im Sinne von mittags).)\\

Wenn wir wie bei \verb|<title>| und \verb|</title>| zwei Tags haben, von denen das eine den Anfang und das andere das Ende von einem Teil unserer Webanwendung definiert, dann bezeichnen wir die beiden als \textbf{öffnendes} bzw. \textbf{schließendes} Tag und beide gemeinsam mit allem, was zwischen ihnen steht als einen \textbf{Containter}\index{HTML!Container}\index{Container}.\\

Wir haben aber auch Container, die zwischen dem öffnenden und dem schließenden Tag keinen eigentlichen Inhalt haben. Um zu verdeutlichen, dass ein Container keinen solchen Inhalt hat, können wir ein öffnendes Tag auch direkt wieder schließen und brauchen kein schließendes Tag zu programmieren. Dazu schreiben wir als letztes Zeichen in einen öffnenden Tag das \verb|\|-Symbol.\\

\textbf{Kontrolle}:

\begin{itemize}
	\item Wie gesagt programmieren Sie in einer Markup Language ausschließlich die Struktur von Anwendungen und weder ihre Funktionalität noch ihre Gestaltung. In sofern war HTML4.01 keine reine Markup Language, sondern eine Mischung aus Markup und Design Sprache.
	\item Sie wissen jetzt, dass die Elemente, aus denen Sie eine Struktur in HTML programmieren Container heißen und das jeder Container aus einem in sich abgeschlossenen Tag oder aus einem öffnenden und einem schließenden Tag besteht.
\end{itemize}

\subsubsection{Dokumentteile auslagern}

Mit HTML-Dokumenten definieren Sie, aus welchen Bestandteilen eine Webanwendung besteht. Sie besteht dagegen nicht aus den konkreten Inhalten. Texte, Bilder, Sound und Videos sind nicht Teil von HTML. Allerdings können wir Texte durchaus direkt ins HTML einfügen, so wie wir das oben getan haben. Das ist allerdings eine Vorgehensweise, die bei größeren Projekten nicht empfehlenswert ist. Vielmehr sollten Sie auch Texte in\\eigenständigen Dateien speichern und sie durch den Webserver ins HTML einfügen lassen. Die einfachste Möglichkeit dafür ist eine PHP-Funktion, die Sie in das HTML-Dokument einfügen.\\

\begin{enumerate}
	\item Erstellen Sie dafür eine Datei mit dem Namen \verb|test_title_001.txt|, in der Sie die folgende Zeile eintragen und die Sie dann im gleichen Verzeichnis wie \verb|seite01.html| abspeichern:
	\begin{verbatim}
		echo("Die erste HTML-Webanwendung");
	\end{verbatim}
	\item Erstellen Sie jetzt eine Datei mit dem Namen\\ \verb|test_begruessung_001.txt| mit dem Inhalt\\ \verb|echo("Einführung in die Programmierung, Teil 1");|.
	\item Ändern Sie die Datei \verb|seite01.html| wie folgte ab und speichern Sie sie unter dem Namen \verb|seite01.php|:
	\begin{verbatim}
	<html>
	<head>
	<title><?php include(test_title_001.txt); ?>
	</title>
	</head>
	<body>
	<?php include(test_begruessung_001.txt); ?>
	</body>
	</html>
	\end{verbatim}
	\item Rufen Sie jetzt im Browser \verb|localhost| auf und wählen Sie dort\\ \verb|seite01.php| an.
\end{enumerate}

Wie Sie sehen sieht die Webpage genauso aus, als wenn Sie \verb|seite01.html| geöffnet hätten. Schauen wir uns die Änderungen und Ihre Auswirkungen einmal im Detail an:

\begin{itemize}
	\item Die Funktion \verb|echo()| ist eine Funktion der Programmiersprache PHP.
	\item Alles, was Sie zwischen zwei Anführungszeichen in die Klammer von echo() schreiben wird ausgegeben.
	\item Eine Programmzeile in PHP wird durch ein Semikolon beendet.
	\item Die PHP-Funktion \verb|include()| lädt den Inhalt einer anderen Datei und fügt ihn an der Stelle ein, wo die include()-Funktion steht.
	\begin{itemize}
		\item Sie können also mit include() beliebige Teile eines \\PHP-Programms in eigenen Dateien speichern.
		\item Das besondere dabei ist, dass Sie somit jeden Teil eines PHP-Programms, der mehrfach genutzt werden soll nur einmal programmieren müssen. (Wenn Sie die objektorientierte Programmierung kennen lernen werden Sie dafür eine andere Möglichkeit kennen lernen.)
	\end{itemize}
	\item Um PHP-Programme oder Programmteile in ein HTML-Dokument einzufügen müssen Sie es in ein Tag eintragen, das mit \verb|<?php| beginnt und mit \verb|?>| endet.
	\item Das Großartige dabei ist, dass Sie auf diese Weise gleich zwei Fliegen mit einer Klappe schlagen:
	\begin{enumerate}
		\item Sie können beliebigen PHP-Code ohne weitere Vorbereitung direkt in HTML einfügen.
		\item Sie können über den oben gezeigten Weg beliebigen HTML-Code aus anderen Dateien an beliebigen Stellen in verschiedene HTML-Dokumente einfügen.
	\end{enumerate}
\end{itemize}

Ausblick \textbf{für Fortgeschrittene}: 

\begin{itemize}
	\item Um Programme oder Programmteile in ein HTML-Dokument zu integrieren, die in JavaScript programmiert wurden, nutzen Sie das\\ \verb|script|-Tag. Wenn Sie beispielsweise die JavaScript-Datei \verb|intro.js| an einer Stelle Ihres HTML-Dokuments einzufügen, lautet das HTML-Tag \verb|<script src=intro.js>|. In HTML4.01 musste deutlich mehr programmiert werden, um JavaScript-Code in HTML einzufügen.
	\item Wollen Sie dagegen JavaScript direkt in HTML programmieren, dann sieht das so aus: \verb|<script> ... Hier steht der JavaScript-|\\\verb|Code ... </script>|. Auch hier gilt wieder: In HTML4.01 musste deutlich mehr programmiert werden, um JavaScript-Code in HTML einzufügen.
	\item \textbf{Hinweis}: Diejenigen von Ihnen, die bei mir den Leistungsnachweis \glqq{}Projekt 1 (MS)\grqq{} erwerben wollen sollten sich das genau merken: Ich brauche in aller Regel nur zwei Sekunden, um zu erkennen, ob Sie HTML4.01 oder HTML5 programmieren. Für den Leistungsnachweis gilt: Die Nutzung von HTML4.01 bedeutet automatisch, dass Sie (noch) nicht bestanden haben.
\end{itemize}

\subsection{Struktur eines HTML-Dokuments}

Damit bleibt die Frage, was die HTML-Tags eigentlich bewirken oder besser gesagt, wie sie von einem Browser interpretiert werden, um daraus die Ansicht zu generieren, die wir als NutzerInnen angezeigt bekommen.\\

\begin{itemize}
	\item Zu Beginn sehen Sie dort den öffnenden Container \verb|<html>|.\\
	Dieser gibt an, dass alles nachfolgende HTML-Code ist. In der letzten Zeile finden Sie dann das schließende Tag \verb|</html>|. Dieses besagt also schlicht, dass jetzt kein HTML-Code mehr folgt.
	\item Danach folgt der \verb|head|-Container.\\
	Wie Sie sehen befindet sich innerhalb dieses Containers der \verb|title|-Container, der definiert, unter welchem Titel die Webanwendung angezeigt wird. Hier werden Sie später auch allgemeine Formatierungen für eine einzelne Webanwendung programmieren.\\
	Grundsätzlich gilt, dass wir nicht unbedingt einen \verb|<head>|-Container programmieren müssen. Aber es macht nur selten Sinn, ihn vollständig wegzulassen.
	\item Danach folgt der \verb|body|-Container.\\
	Dieser beinhaltet all das, was einer Ansicht der Webanwendung angezeigt wird.
\end{itemize}

\textbf{Anmerkung}:\\

Bei HTML wird häufig der Begriff HTML-Skript verwendet, weil es sich ja um kein Programm im dem Sinne handelt, dass hier ein Algorithmus umgesetzt wird. Das ist aber keine allgemeingültige Definition; Sie können also ruhig von einem HTML-Programm oder einer HTML-Seite sprechen, wenn Sie sich damit wohler fühlen. Der von mir angesprochene Unterschied zwischen Skript und Programm wird Ihnen spätestens dann deutlich, wenn Sie mit der imperativen Programmierung in PHP beginnen.\\

\textbf{Kontrolle}:\\

Sie wissen jetzt, dass jedes HTML-Skript drei Container beinhalten sollte, den html-, den head- und den body-Container. Sie haben richtig gelesen: Es sollte diese Container beinhalten, muss es aber nicht. Das HTML-Skript ließe sich also auch mit den folgenden Zeilen programmieren:\\

\begin{verbatim}
	<title>Die erste HTML-Webanwendung</title>
	Willkommen zur Einführung in die Programmierung.
\end{verbatim}

Aus Gründen der Lesbarkeit sollten Sie dennoch immer die etwas umfangreichere Struktur mit html-, head- und body-Container verwenden.

\subsubsection{HTML-Referenz: W3Schools}

Bis Anfang 2015 galt \textbf{SelfHTML}\index{SelfHTML} als die Standardreferenz für HTML. Leider kann ich hiervon mittlerweile nur noch abraten: SelfHTML ignoriert wie die meisten HTML 4.01-Veteranen alles, was HTML 5 zu einer echten nächsten Version von HTML macht. Wenn Sie sich an SelfHTML orientieren, dann können Sie auch gleich bei HTML 4.01 bleiben.\\

Die einzige mir bekannte Webpage, bei der eine klare Trennung zwischen HTML 4.01 und 5 durchgeführt wird ist zum Jahreswechsel 2015/16 (neben dem W3 Consortium, das die Standards festlegt) die Seite \textbf{W3Schools}\index{W3Schools} (\url{http://www.w3schools.com/default.asp}).

\paragraph{Übersicht über alle Tags}

Wir werden in diesem Kurs nur einen kleinen Teil aller Tags besprechen, die es gibt. Und wir werden hier auch jeweils nur einige wenige Anwendungen besprechen können. Damit Sie aber sinnvolle Webanwendung und Webanwendungen entwickeln können, müssen Sie wissen, wo Sie nachschlagen können, wenn Sie mehr Informationen zu einzelnen Tags suchen. Bei den W3Schools nutzen Sie dazu die folgende Unterseite: \url{http://www.w3schools.com/tags/}\\

Hier finden Sie eine vollständige Übersicht über die Tags in HTML. Außerdem finden Sie hier Hinweise darauf, was sich zwischen HTML4.01 und HTML5 geändert hat. Erfahrene HTML-Programmierer werden hier überrascht: Zwar sind alle Bereiche aus HTML entfallen, die mit dem Layout bzw. der Gestaltung zusammen hängen, aber dafür gibt es zum Teil Elemente aus HTML3, die in HTML4 entfernt und in HTML5 wieder hinzugefügt wurden.\\

\textbf{Wichtige Hinweise}:

\begin{itemize}
	\item Auf \url{www.w3schools.com} finden Sie zu jedem Tag Hinweise darauf, welcher Browser das jeweilige Tag unterstützt. Die Angaben dort werden jedoch nicht aktualisiert, sodass der Eindruck entstehen\\ könnte, dass Sie HTML5 praktisch kaum einsetzen können. Das trifft aber nicht zu. Welche Tags tatsächlich von welchem Browser nicht automatisch unterstützt werden und wie Sie dafür sorgen können, dass ein Tag dennoch richtig angezeigt wird, erfahren Sie im Abschnitt zu den sogenannten Polyfills.
	\item Für diejenigen, die bereits in HTML4.01 programmiert haben hier noch ein essentieller Hinweis: Einige Container wie z.B. \verb|<div>|, die bislang sehr oft verwendet wurden, gibt es weiterhin, aber sie sind nur noch in den seltenen Spezialfällen einzusetzen, die mit den neuen Tags in HTML5 nicht abgedeckt sind.
	\item Leider wird an dieser Stelle häufig auf selfhtml verwiesen. Das ist eine Webpage, die sehr detailliert ist, wenn es um HTML4.01 geht. Bezüglich HTML5 ist die Seite leider zurzeit nicht nutzbar. Zu oft werden Sie dort nach dem Lesen eines Abschnitts vor der Frage stehen: Gilt das jetzt immer noch? Deshalb lautet die klare Empfehlung: Nutzen Sie die Seite der W3Schools.
\end{itemize}

\subsubsection{Was haben XML und XHTML mit Webanwendungen zu tun?}

Einer der ersten Versuche, um semantische Webanwendungen zu entwickeln wurde unter der Bezeichnung \textbf{XML}\index{Programmiersprache!XML} (kurz für extended markup language) veröffentlicht. Eine Kombination aus XML und HTML wird als\\ \textbf{XHTML}\index{XHTML}\index{Programmiersprache!XHTML} bezeichnet.

\subsubsection{Validierung - Prüfung auf Fehler}

Bei der Eingabe von Programmcode machen wir unvermeidlich Fehler. Sie haben im vorigen Kapitel den Unterschied zwischen Syntax und Semantik kennen gelernt und wissen deshalb, dass es für einen Computer möglich ist, syntaktische Fehler zu erkennen, aber unmöglich semantische Fehler zu erkennen. Eine weitere Art von Fehlern, die ein Computer nicht erkennen kann hat etwas mit der Logik eines Programms zu tun: Wenn wir in einem Programm etwas einprogrammiert haben, dass der Computer ausführen kann, das aber nicht zu dem Ziel führt, zu dem wir gelangen wollen, dann kann der Computer das mit den bekannten Sprachen nicht erkennen.\\

Vor diesem Hintergrund ist die Behauptung, dass nur \textbf{streng typisierte Sprachen}\index{Typisierung!streng}\index{statisch} sicher seien kompletter Humbug: Sie bieten eine minimale Art von Sicherheit, die aber häufig irrelevant ist. Wer das nicht glauben mag, dem möchte ich einmal empfehlen, sich anzusehen, warum der erste Start der \verb|Ariane V| ein Totalausfall war. Was hat all die ach so großartige Typsicherheit beim Start dieser Rakete gebracht? Gar nichts! Ist Typsicherheit deshalb irrelevant? Nein. Sorgt sie dafür, dass Entwickler ein ungerechtigtes Gefühl von Sicherheit haben? Definitiv. Ist sie somit selbst ein Sicherheitsrisiko? Das können Sie sich selbst beantworten.\\

Kommen wir nun wieder zurück zur Programmierung von HTML-\\Dokumenten. Bislang kennen Sie keine Möglichkeit, um Ihr HTML-\\Dokument auf Fehlerfreiheit zu prüfen. Der Begriff der Fehlerfreiheit ist aber ungenau. Syntaktische Fehler können Sie ja recht leicht durch die Syntaxhervorhebung von notepad++ erkennen. Bei Markup Languages geht es uns aber um die Struktur einer Anwendung, also wäre es schön, eine Möglichkeit zu haben, um zu prüfen, ob die Struktur zumindest \\grundsätzlich den Vorgaben für HTML5 entspricht. Und das wird als \textbf{Validierung}\index{Validierung} bezeichnet.\\

Damit aber ein Browser oder Validator (Programm, das die Validität eines Dokuments prüft) erkennen kann, dass wir ein HTML5-Dokument erstellt haben, müssen wir noch eine Zeile an den Anfang des Dokuments einfügen. Diese Zeile gibt den sogenannten \textbf{Doctype}\index{Doctype}\index{HTML!Doctype} an. Neben der Arbeitserleichterung folgt hieraus auch, dass Sie sich rechtlich etwas absichern: Indem Sie eine validierbare Webanwendung programmieren zeigen Sie, dass Sie nach den aktuellen technischen Standards arbeiten. Und das kann sich im Falle eines Gerichtsverfahrens zu Ihren Gunsten auswirken.\\

Den \textbf{W3C-Validator}\index{Validator!W3C} finden Sie unter \url{http://validator.w3.org}. Hier geben Sie den Link auf die zu prüfende Seite ein und erhalten dann eine Ausgabe über die Validität Ihrer Seite. Alles was Sie tun müssen, um ein HTML-Skript als HTML5-Skript zu markieren ist das Hinzufügen einer kurzen Zeile am Anfang des Skripts (noch vor dem html-Container):\\

\begin{verbatim}
	<!doctype html>
\end{verbatim}

Und das ist alles. Wenn Sie sich nicht sicher sind, ob Sie wirklich HTML5 programmieren wollen, brauchen Sie sich keine Sorgen zu machen: HTML5-Skripte können Passagen enthalten, die wie bei einer früheren HTML-\\Version programmiert sind. Diese werden dann wie bei den früheren Versionen ausgeführt.\\

Wenn wir also unseren bisherigen Code (als HTML5-Code) validierbar machen wollen, dann sieht er so aus:

\begin{verbatim}
	<!doctype html>
	<html>
	<head>
	<title><?php include(test_title_001.txt); ?></title>
	</head>
	<body>
	<?php include(test_begruessung_001.txt); ?>
	</body>
	</html>
\end{verbatim}

Die erste Programmzeile innerhalb eines HTML-Dokuments gibt somit zwei Dinge an, die gemeinsam als \textbf{Doctype Definition}\index{Doctype Definition}\index{HTML!Doctype Definition} (kurz DTD) bezeichnet werden:

\begin{itemize}
	\item Dies ist ein HTML-Dokument.
	\item Die HTML-Version, in der das Dokument erstellt wurde.
\end{itemize}

Bei HTML 4.01 war diese Zeile recht lang und es gab mehr als nur eine Variante. Hier ein Beispiel für eine DTD in HTML4.01:\\

\verb|<!DOCTYPE HTML PUBLIC "-//W3C//DTD|\\\verb|HTML 4.01 Transitional//EN">|\\

Da ist die Variante von HTML5 doch deutlich angenehmer, nicht zuletzt weil es nur genau eine Variante gibt.\\

Wenn Sie Ihr HTML-Dokument mit der DTD gespeichert und den Browser aktualisiert haben, werden Sie feststellen, dass sich die Anzeige nicht geändert hat. Deshalb hier nochmals der Hinweis: Diese Programmzeile teilt dem Webbrowser lediglich mit, dass es sich hier um eine HTML5-Seite handelt. Da es für NutzerInnen einer Webanwendung üblicherweise belanglos ist, wie diese Seite programmiert wurde, wird diese Information auch nicht angezeigt. Der Webbrowser hat damit aber eine wichtige Information erhalten, denn bei der Darstellung einer Seite richten sich Webbrowser unter anderem nach den Sprachen und Versionen, in denen Dokumente verfasst sind.

\subsubsection{Absätze}

Wenn Sie in Ihrer Webanwendung mehrere Absätze Text einfügen wollen, dann machen Sie das mit dem p-Container. Nutzen Sie bitte keinesfalls leere Container oder den \verb|<br \>|-Container, um leere Zeilen einzufügen. Wenn Sie solche Kniffe anwenden, dann programmieren Sie die Ansicht der Webanwendung. Das ist aber Mediendesign und hat in der Programmierung von HTML5 nichts zu suchen.

\begin{verbatim}
	<p> ... Erster Absatz ... </p>
	<p> ... Zweiter Absatz ... </p>
	usw.
\end{verbatim}

Pflegen wir das doch gleich in unsere \verb|.txt|-Dateien ein: Erweitern Sie den Inhalt der \verb|echo()|-Funktion um einige Absätze, die Sie genauso programmieren, als wenn sie direkt im HTML-Dokument stehen würden. (Wenn die Ausgabe nicht ganz so aussieht, wie Sie es erwarten, dann gedulden Sie sich noch ein wenig: Neben einem einfachen Syntaxfehler gibt es noch die Möglichkeit, dass Sie das HTML-Dokument nicht lokalisiert haben, oder dass Sie Sonderzeichen wie \grqq{} verwendet haben, die von der \verb|echo()|-Funktion nicht übernommen werden. Aber keine Sorge, um beide Fälle kümmern wir uns bald.

\subsubsection{Kommentare}

Bei längeren HTML-Dokumenten oder Containern, die nicht selbstredend sind, sollten Sie außerdem Kommentare einpflegen. Kommentare sind Codezeilen, die nicht ausgeführt werden, sondern ausschließlich dazu dienen, um anzuzeigen, was in einem Teil einer Programms oder Skripts passiert. Im Gegensatz zu anderen Containern sieht ein Kommentar wie folgt aus:\\

\verb|<!--| Kommentar, auch über mehrere Zeilen \verb|-->|\\

Bei Kommentar-Containern gibt es also keinen Abschluss durch den Slash, wie das bei anderen Tags der Fall ist.\\

In der Vergangenheit wurden spezielle Befehle, die nur für den Internet Explorer zugeschnitten waren in Form von Kommentaren einprogrammiert; sollten Sie also in fremdem HTML-Skripten Kommentare der Form \\\verb|if IE ...|treffen, dann wissen Sie jetzt, worum es dabei geht.

\subsubsection{Attribute}

Später werden Sie in öffnende Tags noch Attribute einfügen. Attribute legen Einschränkungen oder Erweiterungen fest, die für einen Container gilt und für alles, was sich darin befindet. Diese programmieren Sie ausschließlich ins öffnende Tag. Das schließende Tag beinhaltet weiterhin nur die Bezeichnung eines Containers, um dem Browser anzuzeigen, dass der Container hier \glqq{}zuende\grqq{} ist.\\

Wenn Sie zum Beispiel für den \verb|html|-Container: Wenn Sie hier das \verb|lang|-Attribut festlegen wollen, über das wir noch nicht gesprochen haben und diesem Attribut den Wert \verb|de| zuordnen, sieht das öffnende html-Tag so aus: \verb|<html lang=de>|. Das schließende html-Tag wäre dann aber immer noch \verb|</html>|. Also wäre es unsinnig, hier die Attribute zu programmieren: Attribute gelten immer für einen Container und gelten damit nicht mehr, sobald der Container geschlossen ist.\\

Übrigens legen Sie mit dem \verb|lang|-Attribut die sogenannte Internationalisierung fest. Was das im Detail bedeutet besprechen wir später.\\

\textbf{Für diejenigen, die bereits mit HTML4.01 programmiert haben}: Dort war es üblich, über Attribute die Gestaltung von Containern direkt über das \verb|style|-Attribut zu programmieren. Das passiert unter HTML5 nur noch indirekt über die beiden Attribute \verb|class| und \verb|id|. Bei diesen funktioniert es aber noch genauso wie unter HTML4.01.

\subsubsection{Aufgaben}

\begin{enumerate}
	\item Erstellen Sie jetzt die folgenden sechs HTML-Dokumente, programmieren Sie jeweils DTD und die drei Container:
	\begin{itemize}
		\item arbeitsweg.php
		\item meinCampus.php
		\item meineHobbies.php
		\item meineZiele.php
		\item meinBlog.php
		\item index.php
	\end{itemize}
	\item Erklären Sie in eigenen Worten, warum es für die Ansicht im Browser keinen Unterschied macht, ob die Dateiendung .html oder .php lautet.
	\item (Für Fortgeschrittene, benötigt Recherche im Netz) Erklären Sie in eigenen Worten, warum es für die Ansicht im Browser einen großen Unterschied macht, ob Sie HTML-Dokumente, in denen PHP-Code enthalten ist direkt vom Browser geöffnet oder von einem Webserver (also per localhost) an den Browser übertragen werden.
\end{enumerate}

\subsubsection{Zusammenfassung}

Sie kennen jetzt alles, was Sie benötigen, um eine einzelne Seite mit Text ins Netz zu stellen.

\section{Barrierefreiheit, Internationalisierung und Lokalisierung}

Die meisten Kurse zu HTML4.01 kommen (wenn überhaupt) erst ganz zum Schluss zu diesem Thema, dabei ist es für Webanwendungen essentiell: Dieser Abschnitt vermittelt Ihnen ein paar grundlegende Informationen dazu, wie Sie sicherstellen können, dass Ihre Webanwendung auf den verschiedensten Endgeräten und von den verschiedensten Nutzern genutzt werden kann. Dazu gehört aber vor allem etwas, das bereits mehrfach betont wurde: Programmieren Sie in HTML5 nur dann Design, wenn es anders unmöglich ist.\\

Der Grund für die Bedeutung dieses Kapitels ist so simpel wie ärgerlich:\\

Viele Entwickler vergessen schlicht, dass eine Webanwendung auf einem Smartphone anders dargestellt wird als auf einem Rechner mit einem 2k-Display, das horizontal ausgerichtet ist. Außerdem nutzen nicht nur \\hörbehinderte Personen Software, die Ihnen Webanwendung vorliest. Und zu guter Letzt bieten mehr und mehr Browser eine automatische \\Übersetzung von Texten an.\\

Damit Ihre Webanwendung unter all diesen Bedingungen immer noch gut aussieht, mussten Sie unter HTML4.01 eine ganze Menge Arbeit leisten, die bei HTML5 mit wenigen Befehlen erledigt werden kann. Wobei all die guten Vorsätze nichts Wert sind, wenn Sie im Team jemanden haben, der in HTML Design programmiert.

\subsection{Barrierefreiheit}

Hier geht es darum, eine Webanwendung so zu programmieren, dass Sie auch dann noch gut aussieht, wenn der Nutzer einen starken Zoom-Faktor nutzt oder sich die Webanwendung durch eine Software vorlesen lässt. Darüber hinaus geht es aber auch um Personen, die beispielsweise die Sprache der Webanwendung nicht gut verstehen.

\subsubsection{Aufgabe}

Öffnen Sie die Webpage der HAW mit Ihrem Smartphone und versuchen Sie nun, über die Links auf der Startseite auf die Seite des Departments Medientechnik zu gelangen.\\

Selbst wenn Sie gute Augen haben, werden Sie merken, dass diese Aufgabe sehr anstrengend ist. Und das liegt eben nicht daran, dass es allzu schwer ist, die passenden Links zu finden; vielmehr wurde bei der Webpage der HAW die Barrierefreiheit zum Teil ignoriert. Damit sollte Ihnen klar sein, dass Barrierefreiheit kein belangloses Thema für Randgruppen ist, sondern dass die Missachtung der Barrierefreiheit ein Problem ist, das Nutzer davon abschreckt eine Webanwendung zu nutzen.\\

Es gibt drei einfache erste Prüfungen, um die grundsätzliche Einhaltung der Barrierefreiheit zu prüfen:

\begin{enumerate}
	\item Es gibt einen Seitentitel, der kurz und zutreffend ist und die Seite von anderen Seiten unterscheidet.
	\item Jeder Inhalt in einem Container bekommt eine Überschrift. (Ausnahmen sind z.B. \verb|<p>|-Conatainer.)
	\item Für jedes multimediale Element gibt es eine alternative Bezeichnung, die Sie mit Hilfe des \verb|alt|-Attributs festlegen können. 
\end{enumerate}

Den ersten Punkt können Sie jetzt schon umsetzen, zum zweiten und dritten Punkt kommen wir, sobald wir die entsprechenden Container behandeln.\\

\textbf{Kontrolle}:

\begin{itemize}
	\item Sie verstehen, dass es bei Barrierefreiheit nicht nur um die \\Unterstützung von Menschen geht, die körperlich oder geistig beeinträchtigt sind.
	\item Sie wissen vielmehr, dass die Beachtung der Barrierefreiheit wichtig ist, um Nutzer nicht von der eigenen Webanwendung zu vertreiben.
	\item Ihnen ist klar, dass dazu wesentlich mehr nötig ist, als die drei \\Prüfungen, die Sie gerade kennen gelernt haben. (Für diesen Kurs soll das aber als kleine Einführung genügen.)
\end{itemize}

\subsection{Internationalisierung (kurz i18n) und Lokalisierung (kurz l10n)}

Wenn Sie sich fragen, warum die Abkürzung i18n lautet, hier ist die Antwort: Das englische Wort internationaliziation beginnt mit einem i, hat 18 Buchstaben und endet mit einem n. Auf ganz ähnliche Weise kommen sie von localization zu l10n.\\

Nach der Barrierefreiheit kümmern wir uns nun darum, dass der Browser mit den deutschen Umlauten zurechtkommt. Dazu müssen wir zwei Dinge erledigen:

\begin{enumerate}
	\item Zum einen müssen wir unsere Seite \textbf{internationalisieren}\index{Internationalisierung}. Das bedeutet schlicht, dass wir dem Browser mitteilen, dass unsere Seite auf Deutsch (bzw. in einer anderen Sprache) verfasst wurde. Dieser Schritt dient Browsern mit Übersetzungsalgorithmen, um unsere Seite automatisch \glqq{}richtig\grqq{} zu übersetzen. Sie werden später erfahren, wie wir einzelne Passagen unserer Webanwendung zu programmieren können, dass sie von der automatischen Übersetzung ausgenommen werden.
	\item Danach müssen wir noch die \textbf{Codierung}\index{Codierung} festlegen, damit der Browser weiß, dass wir z.B. deutsche Umlaute verwenden. Dieser Schritt wird als \textbf{Lokalisierung}\index{Lokalisierung} bezeichnet. Im Gegensatz zur Internationalisierung werden Sie die Auswirkung der Lokalisierung direkt auf der Webanwendung sehen.	
\end{enumerate}

Wie Sie Ihre Webanwendung internationalisieren und lokalisieren erfahren Sie direkt im nächsten Abschnitt.

\section{Der head-Container, Meta-Daten und Attribute}

Sie wissen, dass unser html-Container (der auch als \textbf{Wurzelelement} eines HTML-Dokuments bezeichnet wird) die beiden Container head und body enthält. Wenn Sie sich nun die Webanwendung ansehen, dann können Sie sich schon denken, was die beiden unterscheidet: Im head steht alles, was nicht im Fenster des Browsers angezeigt wird. Hier finden sich zusätzliche Informationen und allgemeine Definitionen, die für die gesamte Webanwendung gelten. Wenn es also eine Einstellung gibt, die für alle Container im \verb|<body>| gelten soll, dann werden Sie sie in aller Regel im \verb|<head>| programmieren. Beispielsweise wird hier die Lokalisierung festgelegt. Solche allgemeinen Definitionen, die für eine ganze Webanwendung gelten, werden auch als \textbf{Meta-Daten}\index{Meta-Daten} bezeichnet. Hier der entsprechende Container:

\begin{verbatim}
	<meta charset=utf-8 />
\end{verbatim}


Dieser meta-Container legt fest, dass als Codierung für unsere Webanwendung UTF-8 verwendet werden soll. Codierung ist Teil der Nachrichten- und Kommunikationstechnik, wird aber auch in einführenden Veranstaltungen der Technischen Informatik besprochen.\\

Außerdem sehen Sie, dass der Container am Ende einen / enthält. Wie Sie bereits wissen, gibt es dafür gibt es einen einfachen Grund: Wenn ein Container keinen Inhalt hat, dann können Sie ihn so abschließen und brauchen kein eigenständiges schließendes Tag programmieren. In HTML5 ist das nur dann nötig, wenn ein Container im Regelfall einen Inhalt hat. Hier können Sie also genauso gut die folgende Zeile programmieren:

\begin{verbatim}
	<meta charset=utf-8>
\end{verbatim}

Damit haben Sie auch Ihr erstes Attribut mit einer Wertzuweisung kennen gelernt: \verb|charset| ist das Attribut, \verb|utf-8| der Wert, der diesem Attribut zugeordnet wird.\\

Nun wollen wir unsere Webanwendung internationalisieren. Das Attribut für Sprache lautet \verb|lang|. Da wir aber nicht nur allgemein festlegen wollen, dass eine Sprache verwendet wird (das wäre ja sinnlos), müssen wir noch festlegen, dass die Sprache Deutsch sein soll. Und das tun wir, indem wir mit \verb|lang=de| de als Wert des Attributs festlegen. Im Gegensatz zur Lokalisierung ist lang ein Attribut des html-Containers.\\

Wenn Sie die nötigen Änderungen an Ihren HTML-Dokumenten durchgeführt haben, sieht das also so aus:

\begin{verbatim}
<!doctype html>
<html lang=de>
<head>
<meta charset=utf-8>
<title><?php include(test_title_001.txt); ?></title>
</head>
<body>
<?php include(test_begruessung_001.txt); ?>
</body>
</html>
\end{verbatim}

Sie wollen wissen, welche Codierung Sie für Sprachen wie Farsi (Afghanistan) oder Chinesisch brauchen? Genau dieselbe wie für Deutsch. Eine weitere Anpassung im Rahmen der Lokalisierung ist also nicht nötig. Aber Sie müssen die Internationalisierung in diesen Fällen über das lang-Attribut anpassen.\\

\textbf{Aufgabe}:\\

Nachdem Sie Ihr Dokument um Internationalisierung und Lokalisierung erweitert haben, laden Sie es erneut. Jetzt wird endlich das \verb|ü| im Browser als ein ü angezeigt.

\subsection{Entitys - Umlaute und andere Sonderzeichen}

Es kann jedoch (aufgrund eines veralteten Browsers bei NutzerInnen) immer passieren, das die Lokalisierung nicht funktioniert. Diese Abschnitt erklärt, wie Sie in dem Fall Sonderzeichen einfügen können und diese Methode funktioniert immer:\\

In diesem Fall müssen Sie beispielsweise anstelle des Buchstaben ü die Sequenz \verb|\&uuml;| in den fließenden Text eintragen. Aber das sieht nur auf den ersten Blick unübersichtlich aus: Jede dieser Sequenzen beginnt mit dem kaufmännischen Und-Zeichen und endet mit einem Semikolon.\\

Die Zeichenkette dazwischen ist für alle Umlaute simpel: Zunächst der Buchstabe (a, o, u bei kleinen Umlauten und A, O, U bei großen Umlauten) und dann die Zeichenfolge uml für Umlaut.\\

Ähnliches gilt für die übrigen Sonderzeichen, die bei HTML als Entitys bezeichnet werden. Warum sie nicht entsprechend der englischen Grammatik als Entities bezeichnet werden, kann ich Ihnen nicht sagen. Zu Fragen und Nebenwirkungen wenden Sie sich bitte den Anglisten Ihres Vertrauens.\\

Hier eine Tabelle der für den Einstieg wichtigsten Entities :\\

\begin{tabular}{l l l}
	Ä & \verb|&Auml;|\\
	ä & \verb|&auml;|\\	
	Ö & \verb|&Ouml;|\\	
	ö & \verb|&ouml;|\\	
	Ü & \verb|&Uuml;|\\	
	ü & \verb|&uuml;|\\	
	ß & \verb|&szlig;| & (ß mit Ligatur)\\
	€ & \verb|&euro;|	\\
	\\
	\verb|&| & \verb|&amp;|	& (ampers and)\\
	\verb|>| & \verb|&gt;| & (greater than)\\
	\verb|<| & \verb|&lt;| & (less than)\\
	\\
	Anführungszeichen unten & \verb|&bdquo;|\\
	Anführungszeichen oben & \verb|&rdquo;|	\\
\end{tabular}

Sollten Sie einmal ein Zeichen nutzen wollen, dass Sie in keiner HTML-Tabelle finden, dann gibt es noch eine Lösung: Zeichen, die in der \verb|Unicode|\index{Unicode}-Tabelle bzw. der \verb|ISO 10646|\index{ISO 10646} aufgeführt werden, können wie folgt eingefügt werden. Wählen Sie dazu die Nummer aus der Codetabelle, die Ihrem Zeichen entspricht und fügen es zwischen \verb|&#| sowie dem Semikolon ein. Sollte der Wert ein Hexadezimalwert sein, müssen Sie noch ein \verb|x| einfügen.\\

Beispiel: Nehmen wir an, Sie wollen ein bestimmtes chinesisches Element in Ihrem Text darstellen, dass im Unicode die Codenummer \verb|9FB9| hat. Es ist leicht zu erkennen, dass es sich hier um eine hexadezimale Zahl handelt. Also müssen wir noch ein \verb|x| in \verb|&#    ;| einfügen. Es ergibt sich also folgende Sequenz, mit dem wir das gewünschte Zeichen einfügen können:\\

\verb|&#x9fb9;|\\

\textbf{Kontrolle}\\

Machen Sie das einmal selbst: Laden Sie sich die Unicode-Tabellen herunter (Umfang knapp 130 MB). Fügen Sie dann Ihre Email-Adresse in das HTML-Skript, wobei Sie den Wert für das \verb|@|-Symbol anhand der Codetabelle in Ihren Text einfügen. Sie werden hier nicht lange suchen müssen: Der Eintrag befindet sich gleich auf der ersten Seite in einem der Dokumente, die Sie heruntergeladen haben.\\

Hinweis: Beachten Sie bitte, dass es sich hier um eigenständige Zeichen handelt, die mit dieser Zeichenkette erzeugt werden und nicht etwa um Container oder Tags. Spitze Klammern haben an dieser Stelle also nichts verloren.

\section{Mehr Grundlagen in HTML}

\subsection{Mehr Auslagerung von Code}

\textbf{Aufgabe}:\\

Oben haben Sie gelernt, wie Sie Texte aus Dateien mit Hilfe von PHP in eine HTML-Dokument einfügen können. Stellen Sie sich vor, Sie müssten 95 HTML-Dokumente programmieren und bei allen würde in den ersten drei Zeilen der folgende Code stehen:\\ \verb|<html lang=de><head><meta charset=utf-8>|.\\

Programmieren Sie die Auslagerung dieses Code-Fragments in eine Datei, die per PHP ausgelesen und in ein HTML-Dokument eingefügt wird.\\

\textbf{Hinweis}:\\

Eine Auslagerung von so wenig Code ist meist nicht sinnvoll, weil es Ihnen den Überblick über den Code erschwert. Aber wenn wir zur Programmierung von PHP kommen werden Sie feststellen, dass Sie sich mit dieser Methode viel Tipparbeit ersparen können. Und das bedeutet sehr oft eine deutlich reduzierte Fehleranfälligkeit. Außerdem stellen Sie damit sicher, dass Code-Fragmente, die in mehreren HTML-Dokumenten identisch sein sollen auch dauerhaft identisch sind. Stellen Sie sich umgekehrt den Aufwand und die Fehlerwahrscheinlichkeit vor, wenn Sie in 95 HTML-Dokumenten eine kleine Änderung durchführen müssen.

\textbf{Kontrolle}

\begin{itemize}
	\item Sie wissen, dass jedes HTML-Dokument aus einer Doctype Declaration sowie den drei Containern \verb|html|, \verb|head| und \verb|body| besteht.
	\item Sie haben eine erste Vorstellung davon, was Sie im \verb|<head>| und was Sie im \verb|<body>| programmieren.
	\item Sie wissen, dass Sie Text im Webbrowser anzeigen können, indem Sie ihn innerhalb des \verb|<body>|-Containers eingeben.
	\item Sie verstehen noch nicht genau, wie Sie mit Hilfe von Attributen einzelne Container ändern können.
\end{itemize}

\subsection{Verwendung von Escape-Sequenzen}

Vor HTML5 galt die Aussage, dass Sie grundsätzlich davon ausgehen mussten, dass Sie Sonderzeichen einer Sprache mit sogenannten Entitys programmieren mussten. Diese werden Ihnen auch weiter in HTML-Quellcode begegnen, weil Sie ja beispielsweise eine spitze Klammer nicht als Text in HTML einfügen dürfen.\\

Standardmäßig beherrschen Webbrowser ausschließlich die Zeichen, die in der sogenannten ASCII-Tabelle aufgeführt sind. Für HTML4.01 bedeutet das: Nur Zeichen, die im englischen Alphabet vorkommen können direkt auf einer Webanwendung angezeigt werden. Alle anderen müssen mit einer sogenannten Escape-Sequenz ausgedrückt werden. Diese beginnt mit einem \verb|&|-Zeichen und endet mit einem Semikolon. Das deutsche ß mussten Sie unter HTML4.01 mit der Escape-Sequenz \verb|&szlig;| programmieren.\\

Weiterhin gab es noch die Möglichkeiten, Escape-Sequenzen mit der Nummer der Unicode-Tabelle zu programmieren. Beispielsweise steht \verb|&#x9fb9;| für ein chinesisches Schriftzeichen. Stellen Sie sich einmal vor, Sie müssten auf diese Weise eine Webanwendung Zeichen für Zeichen programmieren...\\

Auch hier zeigt sich, dass die Entwickler beim W3C mit HTML5 einen Standard veröffentlicht haben, der wirklich sinnvolle Änderungen einführt, die auch das Programmieren von Webanwendung deutlich vereinfacht, ohne dabei die Funktionalität oder das Layout von Seiten zu beschränken. Vielmehr ist das Gegenteil der Fall.\\

Es folgen einige Escape-Sequenzen, die Sie auch weiterhin benötigen werden:\\

\begin{tabular}{l l l}
	\verb|&amp;| & \& & (kaufmännisches Und)\\
	\verb|&lt;| & \verb|<| & (less than)\\
	\verb|&gt;| & \verb|>| & (greater than)\\
\end{tabular}

Nehmen wir dazu an, dass Sie innerhalb eines HTML-Dokuments den folgenden Satz angeben wollen:\\

\verb|Die Zeichenfolge <p> öffnet|\\\verb|einen Absatz-Container in HTML|, \\

dann müssen Sie das so einprogrammieren:\\

\verb|Die Zeichenfolge &lt;p&gt; öffnet|\\\verb|einen Absatz-Container in HTML.|\\

Unter HTML4.01 hätten Sie zusätzlich für das ö von öffnet die Entity \verb|&ouml;| eingeben müssen:\\

\verb|Die Zeichenfolge &lt;p&gt; &ouml;ffnet|\\\verb|einen Absatz-Container in HTML.|

\subsection{HTML5: Anführungszeichen sind weitestgehend optional}

Wenn Sie sich ältere HTML-Kurse ansehen, werden Sie feststellen, dass bei Wertzuordnungen wie lang=de der zugeordnete Wert immer in\\Anführungszeichen steht: \verb|<html lang="de">| Das ist bei HTML5 nicht mehr zwingend vorgeschrieben. \\

Wenn Sie allerdings Werte zuordnen, die Leerzeichen beinhalten oder eine Webanwendung für veraltete Browser entwickeln wollen, dann sollten Sie in jedem Fall Anführungszeichen verwenden.

\subsection{Zusammenfassung}

Für den Rest dieses Kapitels werden wir nicht wieder über die Container \verb|<html>| und \verb|<head>| sprechen.

\section{Strukturen von HTML5-Dokumenten}

Auch wenn das offensichtlich sein sollte, sei hier betont: Alle Container, die in diesem Abschnitt besprochen werden können ausschließlich im body-Container eingesetzt werden.\\

All diese Elemente haben in HTML5 eine feste Bedeutung, die insbesondere im Rahmen der Barrierefreiheit von Belang ist. Bei HTML4.01 mussten Webentwickler sich noch mit div-Containern behelfen, denen Sie nicht-standardisierte Attribute zuordneten. Die Folge bestand darin, das Browser die in HTML-Dokumenten vorgegebenen Strukturen nicht erkennen konnten und somit weitgehend willkürlich die Ansicht generierten.\\

Das wiederum brachte viele \glqq{}professionelle\grqq{} EntwicklerInnen dazu, Unmengen an Zeit damit zu verschwenden, HTML-Dokumente mit tausenden Zeilen Code zu erweitern, die letztlich nur dafür sorgen sollten, dass die Ansicht wie gewünscht in jedem denkbaren Browser angezeigt wurde.\\

Deshalb werden Sie heute eine Vielzahl an Frameworks finden, die Ihnen diese Arbeit abnehmen, die aber gleichzeitig garantieren, dass Ihre Webanwendung auf bestimmten Endgeräten oder für bestimmte NutzerInnen grausig aussehen werden, weil z.B. die Barrierefreiheit ignoriert wird. Die Seite der HAW ist da nur ein Beispiel. Schauen Sie sich beispielsweise Seiten auf einem Rechner an, deren Design für Smartphones entwickelt wurde: Zum Teil füllen deren Überschriften ein Viertel des Bildschirms: Das ist mangelhaftes Webdesign! Nehmen Sie bento (einen Ableger von Spiegel online), um einen Eindruck zu bekommen, was hier gemeint ist: \url{http://www.bento.de/}\\

Also nochmal: Ignorieren Sie bitte das Design Ihrer Anwendung, denn so lange Sie nicht über jahrelange Erfahrung in diesem Bereich verfügen werden Sie sonst nur Anwendungen entwickeln, die auf einer Art von Endgerät gut aussehen, auf allen anderen dagegen grausig. Und das ist das Vorgehen von Amateuren.

\subsection{header, footer, main und aside}

Mit diesen vier Containern können Sie eine grobe Struktur Ihrer Webanwendung vorgeben.

\begin{itemize}
	\item Im \verb|<main>| sollen sich alle Inhalte befinden, die auf der Webanwendung zentral angezeigt werden sollen.
	\item Der \verb|<aside>|-Container ist dann für ergänzende Inhalte zu den Inhalten im \verb|<main>| gedacht.
	\item Im \verb|<header>| (nicht zu verwechseln mit dem \verb|<head>|) können Sie beispielsweise ein Unternehmenslogo oder ähnliches unterbringen.
	\item Der \verb|<footer>| dient dann dazu, um beispielsweise einen Verweis auf das Kontaktformular, das Impressum und ähnliches aufzunehmen.
	\begin{itemize}
		\item Der \verb|<nav>|-Container kann in jedem der anderen vier Container untergebracht werden. Er ist vorrangig dafür gedacht, um eine Navigationsleiste zu realisieren. (Wir haben noch nicht darüber gesprochen, wie Sie einen Link auf eine andere Seite programmieren, aber auch dazu kommen wir bald.)
	\end{itemize}
\end{itemize}

Wenn also ein Browser diese Container unterstützt, dann könnte das bedeuten, dass Header und Footer automatisch am oberen bzw. unteren Rand des Bildschirms eingeblendet werden, während NutzerInnern durch die Seite scrollen. Der Main-Bereich würde dann rund zwei Drittel der Breite und der Aside-Bereich ein Drittel des Bildschirms einehmen.\\

Bei Smartphones mit kleinen Displays würden dagegen Header und Footer wahrscheinlich automatisch minimiert werden und Main sowie Aside untereinander angezeigt werden, damit die Ansicht auf dem Gerät im Sinne der NutzerInnen aufgebaut wäre.\\

Es wären auch noch viele weitere Möglichkeiten denkbar, aber letztlich würden gut programmierte Browser diese Entscheidung anhand der Bauweise des Gerätes selbst durchführen. Als HTML-EntwicklerInnen könnten uns dann vollständig darauf konzentrieren, gut strukturierte semantische Webpages zu entwerfen, anstatt den Großteil unserer Zeit damit zu verschwenden jeden denkbaren Fall manuell zu programmieren.

\subsection{article und section}

Diese beiden Container kommen vorrangig im \verb|<main>| und \verb|<aside>| zum Einsatz. Das Konzept sieht wie folgt aus: Wenn Sie wie bei einem Buch die Inhalte Ihrer Webanwendung in Kapitel und Unterkapitel unterteilen wollen, dann beginnen Sie mit einem \verb|<article>|. Sobald ein Unterkapitel beginnt, fügen Sie innerhalb dieses Containers einen \verb|<section>|-Container ein. Wenn Sie dann noch weiter unterteilen wollen, fügen Sie an der entsprechenden Stelle des \verb|<section>| einen \verb|<article>| ein usw. usf. Wichtig  ist nur, dass Sie zum einen mit \verb|<article>| beginnen, und dass Sie die beiden Container-Typen im Wechsel verwenden, wenn Sie jeweils eine weitere unter-Struktur (Unter-Unter-Kapitel zum Unter-Kapitel) beginnen wollen.

\subsection{h1 bis h5}

Alle Container, die Sie in den beiden vorigen Abschnitten kennen gelernt haben, sollen in HTML5 mit einer Überschrift (engl. heading) beginnen. Leider gibt es kein allgemeines \verb|<h>|-Element, mit dem Sie eine Überschrift definieren können.\\

Vielmehr müssen Sie entsprechend der Struktur, die Sie z.B. durch article und section konstruiert haben den passenden Container (\verb|<h1>| bis \verb|<h5>|) auswählen. Durch diese Auswahl legen Sie fest, wie die jeweilige Überschrift angezeigt wird. \verb|<h1>| ist eine Kapitelüberschrift, \verb|<h2>| die Überschrift eines Unterkapitels, usw.

\subsection{p}

Wenn Sie einen article oder eine section in mehrere Absätze unterteilen wollen, dann nutzen Sie dafür den \verb|<p>|-Container. Es gibt zwar auch noch den \verb|<div>|, der bei HTML4.01 sehr oft verwendet wurde, aber fast alles, wofür der dort verwendet wurde wird in aller Regel durch die Container erfüllt, die in den beiden ersten Abschnitten aufgezählt wurden.\\

Der \verb|<div>| ist der einzige Container, für den keine semantischen Merkmale festgelegt werden können. Alleine deshalb sollten Sie im Regelfall \verb|<p>| verwenden. Bitte missverstehen Sie das nicht: Der Inhalt eines div-Containers kann selbstverständlich auch semantische Informationen enthalten, der Container selbst dagegen nicht.\\

\textbf{Für diejenigen, die bereits HTML4.01 programmiert haben}:\\

Wenn Sie Container wie \verb|<div class="main">|\\\verb|<div class="section">| usw. verwenden, ist klar, dass Sie nichts von dem verstanden haben, was hier wir bislang über HTML5 besprochen haben.\\

\verb|<h1>| bis \verb|<h5>|, \verb|<div>| und \verb|<p>| gab es bereits in HTML4.01. In HTML5 haben Sie aber zusätzlich die eine Vielzahl an Containern, die für die standardisierte Strukturierung einer Webanwendung genutzt werden sollen.

\subsection{Aufgabe}

Integrieren Sie die neuen Container in die bisherigen Dateien, auch wenn sie damit leer sind. Vergessen Sie dabei nicht, ggf. über PHP identische Teile unterschiedlicher HTML-Dokumente auszulagern.

\section{Polyfills}

Das englische Wort \textbf{Polyfill}\index{Polyfill} bedeutet schlicht Spachtelmasse. Es geht hier also um Programm-fragmente, die dazu dienen, um Lücken aufzufüllen. Sie werden immer wieder auf Möglichkeiten von HTML5 treffen, die von einzelnen Webbrowsern nicht oder nicht vollständig unterstützt werden. Wenn Sie dann einen Container programmiert haben, wird der im betreffenden Browser nicht wie gewünscht angezeigt und seine Elemente werden wie bei HTML4.01 relativ willkürlich platziert.\\

Aber das ist kein echtes Problem, denn für die meisten dieser Fälle gibt es eine Lösung, die Sie per Copy-Paste in Ihre Webanwendung kopieren können. Und diese Lösungen werden als Polyfill bezeichnet.\\

Wichtig ist hier nicht, dass Sie sich merken, für welche Fälle Sie ein Polyfill benötigen, denn das ändert sich ja kontinuierlich mit jeder neuen Version der verschiedenen Browser. Wichtig ist vielmehr, dass Sie sich merken, auf welcher Seite Sie prüfen können, ob Sie ein Polyfill benötigen und wo Sie es bekommen:

\begin{itemize}
	\item Auf \url{www.caniuse.com} können Sie für jeden HTML5-Container\\prüfen, in welchem Browser er unterstützt wird. Häufig finden Sie bei den einzelnen Containern auch Verweise auf Seiten, auf denen Sie ein passendes Polyfill finden.
	\item Auf \url{www.html5please.com} finden Sie eine Vielzahl an Polyfills.\\
	Merken Sie sich dazu den folgenden kurzen Dialog: 
	\begin{itemize}
		\item What \textbf{can I use}?
		\item \textbf{HTML5}, \textbf{please}.
	\end{itemize}
	Denn damit haben Sie sich schon fast die URLs der beiden Seiten gemerkt.
\end{itemize}

\textbf{Aktualisierung am 15. März 2016}:\\

Es gibt zwar noch Fälle, in denen einzelne HTML5-Container in einzelnen Browsern nicht oder nicht vollständig unterstützt werden.  Vollständigkeit halber werde ich diesen Abschnitt deshalb noch hier belassen, langfristig dürfte die Arbeit mit Polyfills aber überflüssig werden.

\subsection{Einbindung von Polyfills - script-Container}

Polyfills werden in der Sprache \textbf{JavaScript}\index{Programmiersprache!JavaScript}\index{JavaScript} programmiert. Sie brauchen sich jedoch keine Gedanken zu machen, wenn Sie diese Sprache nicht kennen. Denn Sie müssen lediglich einen \verb|<script>|-Container in Ihren \verb|<html>|-Container einfügen. Sämtlichen JavaScript-Code, den Sie verwenden wollen, müssen Sie lediglich in diesen \verb|<script>|-Container kopieren und schon wird er auf Ihrer Webanwendung angewendet.\\

Wichtig ist dabei nur, dass Sie jeweils genau die Bezeichnungen für Container verwenden, die bei HTML5 gelten. Denn genau wie CSS ändern Polyfills die Art, wie ein bestimmter HTML-Container dargestellt wird. Das geht aber nur, wenn die Container die richtige Bezeichnung haben. Sollten Sie sich also vertippen und anstelle des \verb|<aside>|-Containers einen \verb|<aseid>|-Container programmieren, dann wird Ihnen ein Polyfill, dass die Darstellung des \verb|<aside>|-Containers sicherstellt nichts nützen.\\

Auch hier wieder ein Hinweis für fortgeschrittene HTML-Programmierer: In HTML4.01 mussten Sie für die Verwendung von JavaScript noch eine Zeile im \verb|<head>|-Container erstellen, die dem Browser mitteilt, dass \glqq{}Scripte\grqq{} in JavaScript (oder einer anderen Programmiersprache) erstellt werden. Das ist bei HTML5 nicht mehr nötig, weil hier JavaScript die Standardprogrammiersprache ist.

\section{Zusammenfassung}

Die folgenden beiden HTML-Dokumente zeigen, wie Sie mit den bisher vorgestellten HTML5-Elementen eine einfache Webanwendung entwickeln können. Wichtig: Bislang haben Sie noch keine Möglichkeit kennen gelernt, um

\begin{itemize}
	\item Links auf andere Seiten zu erstellen,
	\item Bilder und andere multimediale Inhalte einzufügen oder
	\item die Webanwendung semantisch zu machen.
\end{itemize}

Aber keine Sorge, all diese Punkte und noch viel mehr werden wir in Kürze behandeln.\\

Hier ein Beispiel, in dem der Anfang dieses Skripts als zwei HTML-\\Dokumente zusammengefasst ist. Die Absätze wurden deutlich gekürzt, damit Sie jeweils sehen können, wie die Programmierung aussehen kann.\\

\begin{verbatim}
<!doctype html> 
<html lang=de> 
<head> 
<meta charset=utf-8>
<title>PRG - Vorwort</title> 
</head> 

<body> 
<header>
<!-- Hier später das Logo der Webanwendung einfügen 
-->
</header>

<main>
<h1>Vorwort</h1>
<p>Ein häufiges Missverständnis besteht darin,
dass Programmierung und Informatik miteinander 
verwechselt werden. ....</p> 
</main>

<footer>
<!-- Hier später den Link auf das Impressum einfügen. 
-->
</footer>

<aside>
<article>
<h1>Zusammenfassung</h1>
<p>Informatiker entwickeln Konzepte und Modelle, 
um Ideen möglichst effizient umzusetzen. Dabei 
spielt es keine Rolle, ob diese Konzepte mit 
einem Computer umsetzbar sind.
</p>
<p>Programmieren sind Menschen, die Konzepte 
und Modelle in eine Programmiersprache umsetzen.
</p>
</article>
</aside>
</body> 
</html>

<!doctype html> 
<html lang=de> 
<head> 
<meta charset=utf-8 />
<title>PRG - WWW und semantic Web</title> 
</head> 

<body> 
<header>
<!-- Hier später das Logo der Webanwendung einfügen 
-->
</header>

<main>
<article>
<h1>Vorwort</h1>
<p>Programmierveranstaltungen bereiten Sie in aller 
Regel darauf vor, Programme für einen Computer zu  
....</p> 
<section>
<h2>Programmierung von Webanwendung und 
Webapplicationen</h2>
<p>Die bekannteste Markup Language ist HTML, die 
HyperText Markup Language. ...</p>
<p>Wie gesagt definieren Sie in einer Markup Language 
lediglich  ...</p>
</section>
<section>
<h2>Das semantische Web</h2>
<p>Bis hierher haben Sie nur über Dinge gelesen, die 
Sie unter  ...</p>
<p>Sehen wir uns das mal im Detail an:</p>
<article>
<h3>Syntax und Semantik </h2>
<p>Den einen dieser Begriffe haben Sie wahrscheinlich 
in der Schule kennen und ...</p>
<p>Damit kommen wir zur Semantik. Mit Semantik 
bezeichnen wir ...</p>
<p>Aber es gibt einen sehr großen Unterschied 
zwischen  ...</p>
<p>Stellen Sie sich nun die folgende Situation 
vor, ...</p>
</article>
</section>
</article>
</main>

<footer>
<!-- Hier später den Link auf das Impressum einfügen. 
-->
</footer>

</body> 
</html>
\end{verbatim}

\subsection{Hausaufgabe}

Sie haben vorhin sechs Dateien (arbeitsweg.html usw.) erstellt. Erweitern Sie diese Seiten zum nächsten Mal wie folgt:

\begin{itemize}
	\item Internationalisieren und Lokalisieren Sie jede Seite.
	\item Erstellen Sie für jede Seite eine grundlegende Struktur, bei der Sie insbesondere sämtliche hier vorgestellten HTML5-Container sinnvoll verwenden.
	\item Füllen Sie Ihre Seiten mit Inhalten, die zum Seitentitel passen.
	\item Wenn Sie irgendwelche Inhalte wie Spiele, Videos, Bilder usw. \\einfügen wollen, dann tragen Sie an der entsprechenden Stelle einen Platzhalter ein. (Z.B. „Einzufügen: Bild von Horst“, „Hier mein geniales Gitarrensolo einbauen.“ usw. usf.) Wichtig: Es spielt keine Rolle, ob Sie sich zutrauen, die entsprechenden Inhalte selbst zu entwickeln. Lassen Sie einfach Ihrer Phantasie freien Lauf.
	\item Lassen Sie die Datei \verb|index.html| vorerst so, wie Sie ist.          
	\item Suchen Sie nach einem Polyfill und programmieren Sie es ein, damit der \verb|<aside>|-Container in den folgenden Browsern „richtig“ angezeigt wird: Firefox, Internet Explorer, Safari, Edge
\end{itemize}

\section{Hyperlinks}

Vorhin haben Sie gelernt, dass das Protokoll zur Übertragung von Webanwendung HyperText Transfer Protokoll heißt. Sie wissen bereit, dass das Wort Protokoll nur eine Bezeichnung für eine Vereinbarung darüber, wie etwas zu tun ist. In diesem Fall geht es also um eine Vereinbarung darüber, wie Hypertexte übertragen (transferiert) werden sollen. Also kommen wir kurz dazu, was denn nun wiederum \textbf{Hypertexte}\index{Hypertext} sind und was die mit Webanwendung zu tun haben.\\

Die Antwort ist ganz einfach: Im Gegensatz zu einem Buch beinhaltet eine Webanwendung Kreuzverweise, denen Sie folgen können. Diese Verweise kennen Sie umgangssprachlich als Links. Eine Webanwendung ist also mehr als nur eine Ansammlung von Texten wie bei einem Buch. Und aus diesem Grund wurde das, was wir heute Webpage nennen, in der Zeit als \textbf{Hypertext}\index{Hypertext} bezeichnet, als das WWW gerade erst entwickelt wurde. Wenn Sie also in \textbf{HTML}\index{HTML}\index{Programmiersprache!HTML} programmieren, dann programmieren Sie Hypertext. Nur nennt das heute kaum noch jemand so. Im Namen des Protokolls HTTP lebt dieser Begriff wahrscheinlich noch sehr lange weiter.\\

Damit kommen wir zu den Links, die ursprünglich als Hyperlinks bezeichnet wurden. Das englische Wort Link bezeichnet ja allgemein eine Verbindung. Dementsprechend bezeichnet ein \textbf{Hyperlink}\index{Hyperlink} eine Verbindung zwischen zwei Hypertexten. Jetzt aber genug über Begriffe, schließlich wollen Sie wissen, wie Sie einen Link programmieren können. Warum der so heißt, wie er heißt, dürfte da für Sie nebensächlich sein.

\subsection{Anker}

Auch wenn wir hier in Hamburg sind, wo Sie am Hafen Anker in Hülle und Fülle finden, reden wir an dieser Stelle über Teile einer Webanwendung, wenn wir über einen Anker reden. \textbf{Anker}\index{Anker} sind bei HTML Container, auf die ein Link verweisen kann. In anderen Worten: Wenn Sie in Ihrem HTML-Dokument einen Anker definieren, dann können Sie von einer beliebigen anderen Stelle aus auf diese Stelle verweisen. Sie können dann also an einer beliebigen Stelle einen Link einprogrammieren, mit dem ein Nutzer genau bei einem bestimmten Anker landet.\\

Wie alles andere in HTML waren Anker ursprünglich vollwertige Container. Deshalb können sie auch als eigenständige Container programmiert werden. Sinnvoller ist es allerdings, Container mittels des id-Attributs als einen Anker zu programmieren. Hier ein Beispiel für einen Hypertext, in dem ein Überschrift-Container als Anker programmiert wurde:

\begin{verbatim}
...
<main>
<article>
<h1>Mein leckerstes Fleischgericht</h1>
<p>Dieses Rezept habe ich von meiner Oma, die ...</p>
<p>Als sie dann 1972 in ...</p>
<section>
<h2 id=blanchieren>Blanchieren und andere 
Zubereitungsarten</h2>
<p>Und dann sagte sie ...</p>
</section>
... 
\end{verbatim}

Auch wenn es naheliegend ist: In einem HTML-Dokument darf jedes \textbf{id}\index{id}-Attribut nur einmal verwendet werden. Das heißt nicht, dass Sie jeweils nur einen Anker programmieren dürfen, sondern dass Sie z.B. innerhalb eines HTML-Dokuments nur einmal \verb|id=blanchieren| einprogrammieren dürfen.

\subsubsection{Aufgabe:}

\begin{itemize}
	\item Programmieren Sie einige Anker in Ihre HTML-Dokumente.
\end{itemize}

\subsection{Links}

Es gibt drei wichtige Varianten von Links, die aber im Großen und Ganzen gleich programmiert werden.\\

Wenn Sie auf eine andere Seite verlinken wollen, dann nutzen Sie dazu den Container \verb|<a href ...>|. Das a am Anfang ist noch ein Überbleibsel aus der Zeit, als Anker in Form das \verb|<a>|-Containers programmiert wurden. Wie gesagt wird dafür heute das \verb|id|-Attribut verwendet.\\

Hier die drei genannten Varianten:

\begin{itemize}
	\item Sie wollen auf einen Anker verlinken, der sich im selben HTML-\\Dokument befindet, aus dem heraus Sie ihn verlinken wollen. Bsp.: Sie haben ein kleines Glossar auf Ihrer Seite, in dem Sie den Anker „blanchieren“ einprogrammiert haben. Ein Nutzer soll innerhalb dieses Glossars zum Anker springen können. Dann sieht der Link-Container so aus:
	\begin{verbatim}
	<a href=blanchieren> Beliebiger Text, der auf der 
	Webanwendung unterstrichen angezeigt wird und damit 
	anzeigt, dass hier ein Link vorhanden ist. </a>
	\end{verbatim}
	\item Sie wollen auf eine andere Webanwendung verlinken. Dann tragen Sie nach dem Gleichzeichen die vollständige URL ein. (Was eine URL ist, klären wir gleich.) Im folgenden Beispiel programmieren wir einen Link auf die Webanwendung des Departments Medientechnik:
	\begin{verbatim}	
	<a href=http://www.mt.haw-hamburg.de>
	Zum Department Medientechnik</a>|
	\end{verbatim}
	\item Nehmen wir an, Sie wollen dagegen auf einen Anker auf einer anderen Seite verweisen. Dann geben Sie zunächst die URL der Seite an, gefolgt von einem Hash (das ist dieses Zeichen: \verb|#|) und gefolgt vom Namen des Ankers. Nehmen wir an, die Seite heißt\\ \verb|meineRezepte.html| und der Anker heißt \verb|kohlroulade|. Dann könnte der Link so aussehen:
	\begin{verbatim}
	Zu meinem Rezept für 
	<a href=meineRezepte.html\#kohlroulade>
	Kohlrouladen</a>.
	\end{verbatim}
\end{itemize}

\subsubsection{Aufgabe:}

\begin{itemize}
	\item Programmieren Sie jetzt einige Links auf die verschiedenen Anker Ihrer Webanwendung.\\
	
	(Sie haben doch die letzte Aufgabe erfüllt, in der Sie Anker programmieren sollten, nicht wahr?)
\end{itemize}

\subsection{Verlinkungen als expliziter Download}

Bei HTML4.01 bewirkt das Anwählen eines Hyperlinks, dass der Browser versuchen wird, die Datei zu öffnen. Erst wenn er feststellt, dass es sich um ein Format handelt, dass er nicht öffnen kann, wird er einen Download anbieten. Mit HTML5 wurde für \verb|<a href>|-Container das \verb|download|\\-Attribut eingeführt. Darüber können Sie explizit angeben, dass ein Link heruntergeladen werden soll.\\

Wenn Sie diesem Attribut einen Namen als Wert übergeben, dann geben Sie dem Browser vor, unter welchem Namen die Datei gespeichert werden soll. Das ist vor allem dann von Vorteil, wenn der Dateiname eher kryptisch ist.

\begin{verbatim}
<a href=DC9287349723.jpg 
download=FenderAmericanVintage.jpg>
Foto meiner Gitarre</a>
\end{verbatim}

\subsection{Hausaufgabe:}

\begin{itemize}
	\item Erstellen Sie einige Bilddateien, damit Sie diese nutzen können, um explizite Links in Ihrem HTML-Dokumenten einprogrammieren\\ können.\\
	
	\textbf{Wichtig}:\\
	
	Sie müssen diese Bilddateien selbst erstellt haben und dürfen keine rechtlich geschützten Gegenstände aufnehmen. Sie sollten ebenfalls darauf achten, dass keine Personen auf den Bildern zu sehen sind, außer wenn Sie das schriftliche Einverständnis dieser Personen haben. Denn auch wenn die Bilddateien vorerst nicht veröffentlicht werden sollen, könnten Sie ansonsten rechtliche Probleme bekommen, bei denen durchaus Bußgelder im vierstelligen Bereich drohen.\\
	
	Diesen Hinweis können Sie auf alle Daten und Dateien beziehen, mit denen Sie arbeiten. Es spielt hier zunächst keine Rolle, ob sie Dateien selbst erstellen oder \glqq{}nur\grqq{} weiterverwenden. Auch wenn Sie sie gar nicht veröffentlichen kann es teuer werden: Die Rechtslage ist hier sehr schnell gegen sie. Mehr darüber lernen Sie in der Veranstaltung Medienrecht. Wenn Sie hier wie unsere Studierenden in Media Systems von einem Anwalt unterrichtet werden, dann können Sie sich freuen, denn der kann Ihnen nicht nur erklären, wie die Rechtslage auf dem Papier ist, sondern auch wie tatsächlich im Gerichtssaal entschieden wird und was all diese Gesetzestexte bedeuten.
\end{itemize}

\subsection{URLs – absolute und relative Adressen}

Wenn Sie im WWW unterwegs sind, rufen Sie Seiten wie \\\verb|www.haw-hamburg.de| auf. Eine solche Adresse wird als Uniform Resource Locator (kurz \textbf{URL}\index{URL}) bezeichnet. Aber auch wenn das Protokoll angegeben wird (wie bei \verb|http://www.haw-hamburg.de|) und in einer Reihe weitere Fälle spricht man von einer URL. Auch \glqq{}Adressangaben\grqq{}, die sich auf Dateien auf Ihrem Computer beziehen werden als URL bezeichnet. Kurz gesagt ist eine URL eine standardisierte Angabe darüber, wo eine Datei zu finden ist.\\

Eine \textbf{absolute URL}\index{URL!absolut} ist nun eine URL, die den vollständigen Pfad zu einer Datei angibt. (Zur Erinnerung: Das WWW ist nichts als eine Ansammlung von Dateien auf Rechnern, die weltweit vernetzt sind.)\\

Im Gegensatz dazu ist eine \textbf{relative URL}\index{URL!relativ} eine Adressangabe, die den Pfad von dem Standort aus beschreibt, an dem die Datei gespeichert ist, in der die URL einprogrammiert wurde. Meist werden Sie aus einem einfachen Grund mit relativen URLs programmieren: Da die Dateien bei der Programmierung nicht an derselben Stelle gespeichert sind wie später, wenn sie online abrufbar sind, müssten Sie bei absoluten URLs später alle Adressen einmal ändern und würden mit Sicherheit Fehler erzeugen.\\

Ein \glqq{}exzellentes\grqq{} Beispiel finden Sie unter den Tutorials zu Java. Dort wurden viele Links absolut programmiert. Als dann Java von Sun Systems an Oracle verkauft wurde, wurden nicht alle Links überarbeitet. Heute können Sie einzig aus diesem Grund viele Tutorials nicht aufrufen: Da der Link mit\verb|www.sun.com| beginnt, die entsprechende Seite aber bei \\\verb|www.oracle.com| liegt, führt der Link ins Leere. Häufig wurden die entsprechenden Tutorials dann auf \verb|www.oracle.com| in einem anderen Verzeichnis als bei \verb|www.sun.com| gespeichert, sodass auch eine manuelle\\Änderung von \verb|sun| in \verb|oracle| nicht hilft, um das Tutorial zu finden.\\

Bei URLs, die nicht auf einen Dateinamen enden, suchen Webbrowser automatisch nach einer Datei namens \verb|index.html|. Deshalb ist es wichtig, dass Sie bei einer Webanwendung immer eine Datei index.html einprogrammieren. (Ausnahmen sind Webpages und Webanwendungen, die Sie mithilfe eines Frameworks, eines CMS oder anderer \glqq{}Hilfen\grqq{} erstellen.\\

Aber wenn Sie beispielsweise eine Webanwendung programmieren, die aus mehreren HTML-Dokumenten besteht, dann brauchen Sie für einen Link von einem dieser Dokumente zum anderen nicht die absolute URL angeben. Nehmen wir an, alle HTML-Dokumente Ihrer Seite würden innerhalb eines Verzeichnisses liegen. Dann brauchen Sie nur den Dateinamen des HTML-Dokuments als URL angeben, auf das Sie verlinken wollen. Eine solche URL wird dementsprechend als \textbf{relative URL}\index{URL!relativ} bezeichnet.\\

Wichtig ist aber vor allem, dass Sie grundsätzlich verstehen, was eine URL ist und wie sie syntaktisch richtig geschrieben wird.

\section{Formulare}

\textbf{Formulare}\index{Formulare} sind Bereiche einer Webanwendung, über die Nutzer Daten per Tastatur oder Maus eingeben können. Interaktive Elemente wie Spiele \\können auch dazu gehören.\\

Wie Sie wissen können Sie mit HTML lediglich Container definieren, deren Darstellung über CSS festgelegt wird. Wenn Sie dann noch Nutzereingaben verarbeiten wollen, benötigen Sie zusätzlich eine Programmiersprache wie PHP oder JavaScript.\\

Da Sie also mit HTML alleine eine Nutzereingabe nicht verarbeiten können macht es scheinbar wenig Sinn, in HTML Formulare zu erstellen. Auf der anderen Seite wird ja in HTML definiert, aus welchen Elementen eine Webanwendung zusammengestellt wird. Und da auch Formulare solche Elemente sind bzw. aus solchen Elementen zusammengestellt werden, müssen wir uns bei der Programmierung in HTML mit Formularen beschäftigen.\\

Hier sind wir dann auch an einem Punkt angelangt, wo die sonst sehr klare Trennung zwischen HTML und PHP verschwimmt: Alles, was mit Formularen zu tun hat müssen sowohl PHP-EntwicklerInnen als auch HTML-EntwicklerInnen beherrschen.

\subsection{Elemente eines Formulars}

Wie alles andere in HTML programmieren wir auch Formulare  als Container. Hier ist es der \verb|<form>|-Container.\\

Wie gewohnt können Sie über das \verb|id|-Attribut ein Formular zu einem Objekt im Sinne des DOM machen, das einen Namen hat und auf das verlinkt werden kann.

\begin{verbatim}
<form id=registrierung>
<!- - Hier werden die einzelnen Eingabemöglichkeiten von Nutzern einprogrammiert. - ->
</form>
\end{verbatim}

Der \verb|<form>|\index{HTML!Container!form|}-Container ist das Wurzelelement für Formulare, so wie der <html>-Container das Wurzelelement für HTML-Dokumente ist: Alles, was ein Nutzer eingeben darf oder soll wird einfach in Form verschiedener Container in den <form>-Container einprogrammiert. Sie können in jedem HTML-Dokument beliebig viele <form>-Container programmieren.\\

Die Grundidee eines Formulars ist, dass NutzerInnen hier verschiedene Angaben machen und Optionen anwählen können, die dann gewissermaßen als ein Paket verarbeitet werden. Deshalb brauchen Sie in jedem Formular ein Element, das einzig dafür da ist, dass der Nutzer bestätigt, dass alle Daten des jeweiligen Formulars abgeschickt werden sollen. Und auch wenn Sie beliebig viele Formulare auf einer Seite programmieren können, sollten Sie möglichst nicht zu viele individuelle Formulare programmieren, da Nutzer sonst mehr damit beschäftigt sind, die vielen Formulare einzeln abzusenden, als damit, das nötige Formular auszufüllen.\\

Später werden die Eingaben von Nutzern wie beschrieben an Programme weiter gegeben, die z.B. in PHP oder JavaScript programmiert wurden. Diese Datenübergabe steuern Sie dann durch zwei Attribute des <form>-Containers: Das \verb|action|\index{HTML!Attribut!action}-Attribut gibt die URL des Programms an, das steuert, wie mit den Eingaben des Nutzers umgegangen werden soll. Das \verb|method|\index{HTML!Attribut!method}-Attribut ist für die Übertragung per HTTP wichtig und steuert, wie die Daten an das Programm übertragen werden. Da wir uns momentan auf die Programmierung eines Formulars in HTML kümmern, dessen Eingaben noch nicht von einem Programm verwendet werden sollen, lassen wir diese Attribute vorerst außen vor.\\

Wie gewohnt wird die genaue Darstellung bzw. die Anordnung der Elemente im Webbrowser später über CSS programmiert.\\

Wichtig: Im Gegensatz zu HTML4.01 bietet Ihnen HTML5 eine Vielzahl an Möglichkeiten, damit Sie prüfen können, ob die Eingabe eines Nutzers valide ist. Bei einem Datum ist es dann beispielsweise unmöglich, den 32. Dezember einzugeben. Die entsprechenden Kontrollfunktionen mussten Sie vor HTML5 mithilfe einer Programmiersprache wie PHP oder JavaScript selbst programmieren.

\subsection{Das name-Attribut und das id-Attribut – Sonderfälle in Formularen}

Innerhalb eines \verb|<form>|-Containers erstellen Sie für jede \\Eingabemöglichkeit einen weiteren Container. Damit Sie die Eingaben \\
später weiter verwenden können, müssen Sie bei vielen Containern ein \verb|name|\index{HTML!Attribut!name}-Attribut programmieren, dessen Wert innerhalb des \verb|<form>|\\-Containers nur einmal vorkommen darf. \\

Wenn Sie sich jetzt wundern, warum hier nicht mehr das \verb|id|- sondern das \verb|name|-Attribut verwendet werden muss: Das \verb|id|-Attribut wurde mit HTML5 so erweitert, dass Elemente einer Webanwendung als Objekte in einer objektorientierten Sprache verwenden werden können. Das \verb|name|-Attribut wird für die Übergabe von Nutzereingaben eines Formulars an ein Programm verwendet. Deshalb gibt es bei Formularen beide Attribute (\verb|name| und \verb|id|).\\

Bei allen imperativen Programmiersprachen werden Werte gespeichert, indem sie jeweils einer Variablen zugeordnet werden. Eine Variable hat einen Bezeichner und einen Datentyp. In diesem Buch verwende ich den Begriff des Bezeichners auch um Verwechselungen mit dem \verb|name|-Attribut zu vermeiden. Bei den meisten imperativen Programmiersprachen müssen Sie den Bezeichner festlegen, bevor Sie ihn nutzen dürfen. Danach können Sie mit dem Wert der Variable an mehreren Stellen etwas tun. Das macht vor allem dann Sinn, wenn ein Wert sich immer wieder ändern kann oder er an vielen Stellen innerhalb eines Programms geändert werden kann bzw. soll.\\

Der Typ einer Variablen sagt etwas darüber aus, um was für eine Art von Variable es sich handelt. Für Sie und mich ist es beispielsweise klar erkennbar, ob eine Zeichenfolge nun ein Text ist oder ein Datum, eine Rechenaufgabe oder etwas anderes. Für einen Computer ist das nicht klar. Ein Computer kann z.B. nicht unterscheiden, ob die Zeichenfolge 10 die Zahl 10 oder die Zahl 2 (binär 10) oder der Text 10 sein soll; all diese Interpretationen werden innerhalb des Computers unterschiedlich gespeichert und verarbeitet. Deshalb gibt es bei der Nutzung von Variablen innerhalb eines Computerprogramms immer einen Typ für jede einzelne Variable.\\

Wichtig: In Sprachen wie Java wird der Typ für jede Variable vom Programmierer festgelegt und kann sich dann nicht mehr ändern. Diese nicht-Änderbarkeit des Datentyps einer Variablen wird als \textbf{statische Typisierung}\index{Typisierung!statisch} bezeichnet. Daneben gibt es noch die \textbf{dynamische Typisierung}\index{Typisierung!dynamisch}. Hier wird der Typ einer Variablen von der Programmiersprache verwaltet und bei Bedarf geändert. Schon vorweg sei gesagt, dass PHP eine dynamisch typisierte Sprache ist. Beide Verfahren haben unterschiedliche Vor- und Nachteile und keines (!) ist schlecht. Insbesondere ist die Aussage, dass die dynamische Typisierung unsicher sei kompletter Humbug; es gibt eine Art von Sicherheit, die durch die statische Typisierung sicher gestellt wird, aber gleichzeitig ist sie der Grund für eine Vielzahl überflüssiger Fehlermeldungen.

\subsection{Container für Formulare}

Die restlichen Inhalte des Kapitels sollten Sie überfliegen, um sich zunächst einen groben Überblick darüber zu verschaffen, welche Arten von Eingaben HTML5 direkt unterstützt. Normalerweise hätte ich Sie hierfür auf die Webanwendung der W3Schools verwiesen, aber leider sind dort die Tags nach Ihrem Namen und nicht nach der Funktion sortiert. Das ist für Einsteiger eher verwirrend, denn so brauchen Sie eine ganze Weile, um z.B. das passende Tag zu finden, wenn Sie wollen, dass der Browser prüft, ob eine Eingabe ein reales Datum sein kann oder nicht.\\

Wichtig: Während viele dieser Eingabemöglichkeiten auf einem Rechner nur die Kontrolle durchführen, ob eine Eingabe des Nutzers zum jeweiligen Typ passt, öffnen sich bei Smartphones häufig kleine Fenster, über die Nutzer z.B. ein Datum anwählen können. Auch hier gilt wieder: Vor HTML5 hätten Sie solche Komfortfunktionen noch selbst programmieren müssen, mit HTML5 brauchen Sie sich um eine solche Programmierung nicht zu kümmern. Alles, was Sie hier tun müssen, ist das passende Tag auszuwählen.

\subsubsection{Formularfelder für Texteingaben}

In diesem Unterabschnitt finden Sie die meisten Typen, die Sie nutzen \\können, damit Nutzer einen Text oder eine Zahl eingeben können. Wenn ein Tag hier nicht aufgeführt ist, dann liegt das daran, dass Sie wie bei Formular-Tags in HTML 4.01 etwas programmieren müssten, damit die betroffenen Tags ihre Aufgabe erfüllen. Ein Beispiel ist das Tag, mit dem Sie es einem Nutzer ermöglichen können, nach einem Begriff zu suchen. Denn die Suche müssen Sie dann doch wieder selbst programmieren. Also taucht es hier nicht auf.

Die folgenden beiden Attribute können Sie bei allen Formularfeldern verwenden: (Ausnahmen sind jeweils angegeben, zum Teil können Sie sich das aber auch logisch erschließen.)

\begin{itemize}
	\item Das \verb|value|-Attribut\\
	Bei allen Formular-Containern (außer dem \verb|file|-Container) können Sie mit dem \verb|value|-Attribut eine Antwort eintragen, die der Nutzer aber jederzeit überschreiben kann. Wenn ein Nutzer das nicht tut, wird dieser Wert beim Absenden des Formulars so übertragen, als wenn der Nutzer ihn eingetragen hätte.

	\item Das \verb|required|-Attribut\\
	Sie können festlegen, dass Nutzer einzelne Felder ausfüllen müssen, bevor sie ein Formular absenden können. Dazu programmieren Sie schlicht das Attribut \verb|required|.
\end{itemize}

Jetzt folgen die meisten der Container, die Sie verwenden können, damit NutzerInnen alphabetische oder alphanumerische Eingaben durchführen können:

\begin{itemize}
	\item \textbf{Kurzer Text}\\	
	\textbf{Zweck}: Damit können Nutzer einen kurzen Text von bis zu 20 Zeichen eingeben.\\	
	\textbf{Quellcode}: \verb|<input>| (alternativ: \verb|<input type=text>|)\\	
	Wenn Sie hier das Attribut \verb|type=password| vergeben, dann wird die Eingabe maskiert; niemand kann also am Monitor sehen, was der Nutzer eingibt. Das ist aber nur ein Schutz gegen neugierige Kollegen, die nicht verfolgen können, welche Tasten der Nutzer drückt. Gegen die meisten Angriffsarten ist es dagegen vollkommen nutzlos. Um Nutzereingaben gegen diese zu schützen müssen Sie im Programm kryptographische Protokolle integrieren und sollten am besten keine Tastatureingaben als Passwort verwenden. Aber das ist ein Thema für Veranstaltungen in höheren Semestern.\\

	\item Langer Text\\
	\textbf{Zweck}: Mit diesem Container ermöglichen Sie es Nutzern, Texte beliebiger Länge einzugeben. Im Gegensatz zu anderen Containern \\können Sie hier mit den Attributen rows und cols die Größe festlegen. Tipp: Auch wenn es im Moment nicht so gut aussieht, nutzen Sie dazu besser CSS.\\
	\textbf{Quellcode}: \verb|<textarea>|\\

	\item URL eingeben\\
	\textbf{Zweck}: Nutzer können eine URL eingeben. Einziger Vorteil gegenüber \verb|type=text| ist die größere Länge.\\	
	\textbf{Quellcode}: \verb|<input type=url>|\\

	\item Emails:\\
	\textbf{Zweck}: Hier prüft der Browser, ob die Eingabe eine valide Email-Adresse sein kann: Ist das @-Symbol enthalten? Gibt es eine valide Endung? usw.\\	
	\textbf{Quellcode}: \verb|<input type=email>|\\
\end{itemize}

\textbf{Beispiel für ein einfaches Formular}:

\begin{verbatim}
<form>
Nutzername: <input name=username required>
E-Mail: <input type=email name=email required>
Webanwendung: <input type=url name=webpage>
Ihr Anliegen: <textfield name=userrequest required>
</form>
\end{verbatim}

\subsubsection{Formularfelder für Zahleneingaben}

Jetzt die Formularfelder, die für verschiedene numerische Eingaben gedacht sind:

\begin{itemize}
	\item Zahlen eingeben:\\
	\textbf{Zweck}: Hier können Nutzer ganze Zahlen eingeben. Eine Eingabe ist auch per Maus möglich, da zusammen mit dem Eingabefeld noch zwei kleine Schaltflächen eingeblendet werden, über die der Wert erhöht oder gesenkt werden kann.\\	
	Für diese diesen input-Typ können Sie die selben Attribute verwenden, die auch beim nachfolgenden input-Typ \verb|range| gelten. \\	
	\textbf{Quellcode}: \verb|<input type=number>|\\
	Tipp: Verwenden Sie \verb|number|, wenn Nutzer eine genau Zahl eingeben sollen und \verb|range|, wenn ein grober Wert als Eingabe genügt.

	\item Zahlen mit einem Schieber auswählen:\\
	\textbf{Quellcode}: \verb|<input type=range min=... max=...>|\\
	Im Gegensatz zum Typ \verb|number| müssen Sie hier die Attribute \verb|min| und \verb|max| vorgeben, weil Nutzer kein Feld für eine Eingabe erhalten, sondern einen Slider (zu Deutsch Schieberegler), mit dem sie einen Wert anwählen können. Über das Attribut \verb|step| können Sie zusätzlich programmieren, wie groß der Abstand zwischen zwei wählbaren Zahlen sein darf.

	\item Telefonnummern:\\
	\textbf{Quellcode}: \verb|<input type=tel>|\\
	\textbf{Zweck}: Der Name sagts schon: Damit können Nutzer eine Telefonnummer eingeben. Der Vorteil gegenüber \verb|type=number| besteht darin, dass so auch eine internationale Vorwahl eingegeben werden kann. Wegen des + ist das bei \verb|number| nicht möglich. (Streng genommen handelt es sich hier also nicht um einen Typ für Zahleneingaben, aber da die meisten Menschen Telefonnummern als Zahlen betrachten, habe ich es in diesem Abschnitt eingruppiert.)
\end{itemize}

Hier ein weiteres Beispiel für ein einfaches Formular:

\begin{verbatim}
<form>
Nutzername: <input name=username required>
E-Mail: <input type=email name=email required>
Telefon: <input type=tel name=phonenumber>
Webanwendung: <input type=url name=webpage>
Ihr Anliegen: <textfield name=userrequest required>
Ihre Dringlichkeit: <input type=range name=importancy min=1 max=9>
</form>
\end{verbatim}

\subsubsection{Formularfelder für Datumsangaben und Zeitpunkte}

Zwar setzen sich Datums- und Zeitangaben größtenteils aus Zahlen zusammen, aber bei den folgenden Typen geht es darum, sicher zu stellen, dass die Eingabe(n) von Nutzerinnen reale Zeitpunkte sind.\\

\textbf{Wichtig}:\\

Es gibt kein Formularfeld, das Zeiträume aufnehmen kann: Sie können zwar Einen Anfangszeitpunkt und einen Endzeitpunkt als Formularfeld programmieren, aber beide werden auch in HTML5 selbst nicht als Zeitraum, sondern als zwei individuelle Zeitpunkt betrachtet, die keinen Zusammenhang haben. Bei der Auswertung z.B. in PHP müssen sie das ggf. \glqq{}korrigieren\grqq{}.

\begin{itemize}
	\item Datum\\
	\textbf{Zweck}: Bei Smartphones öffnet sich in diesem Fall ein Feld, über das Nutzer ein Datum, wie z.B. ihr Geburtsdatum anwählen können.	
	\textbf{Quellcode}: \verb|<input type=date>|
	
	\item Monat und Jahr\\
	\textbf{Zweck}: Hier können Nutzer Monat und Jahr eingeben.\\	
	\textbf{Quellcode}: \verb|<input type=month>|

	\item Monat und Jahr\\
	\textbf{Zweck}: Hier können Nutzer Woche und Jahr eingeben.\\	
	\textbf{Quellcode}: \verb|<input type=week>|
	
	\item Uhrzeit\\	
	\textbf{Zweck}: Hier kann eine Uhrzeit eingegeben werden.\\	
	\textbf{Quellcode}: \verb|<input type=time>|

	\item Datum und Uhrzeit\\
	\textbf{Zweck}: Zusätzlich zu \verb|type=date| bietet dieser Typ noch die Angabe einer Uhrzeit an. Der Typ datetime (ohne –local) ist nicht gültig.\\
	\textbf{Quellcode}: \verb|<input type=datetime-local>|
\end{itemize}

Weiteres Beispiel für ein einfaches Formular:

\begin{verbatim}
<form>
Nutzername: <input name=username required>
E-Mail: <input type=email name=email required>
Telefon: <input type=tel name=phonenumber>
Webanwendung: <input type=url name=webpage>
Ihr Anliegen: <textfield name=userrequest required>
Ihre Dringlichkeit: <input type=range name=importancy 
min=1 max=9>
Für Anrufe teilen Sie uns bitte noch mit, wann wir 
Sie am besten erreichen. Von <input type=time 
name=callNoEarlierThan> bis <input type=time 
name=callNoLaterThan>.
</form>
\end{verbatim}

\subsubsection{Auswahlmöglichkeiten}

Die input-Typen, die Sie bis jetzt kennen gelernt haben, lassen Nutzern eine große Freiheit bei der Eingabe. Einzig das Format (z.B. bei einer Telefonnummer) muss stimmen. Sie als Entwickler können dabei keine Antwortmöglichkeiten fest vorgeben. Für ein Bestellformular bei einem Lieferservice sind diese Formularfelder deshalb nicht ausreichend.\\

Es folgen Eingabefelder, die dafür gedacht sind, dass Sie Nutzern eine Reihe an Wahlmöglichkeiten anbieten.\\

Im Gegensatz zu den bisherigen \verb|input|-Containern können Sie hier die Beschriftung einfach dadurch vornehmen, dass Sie sie innerhalb des Containers programmieren. Besser ist die Nutzung des \verb|<label>|-Containers, zu dem wir im Anschluss kommen.\\

\begin{itemize}
	\item Checkboxen:\\
	\textbf{Quellcode:}\\\verb|<input type=checkbox name=bezeichner value=wert>|\\
	Damit programmieren Sie ein Kästchen, das von Nutzern an- oder abgewählt werden kann.\\
	Die Attribute \verb|name| und \verb|value| werden erst dann von Belang, wenn Sie ein Programm entwickeln, mit dem Sie die Nutzereingaben verwenden wollen (für den Moment können Sie das folgende also überspringen): 
	
	\begin{itemize}
		\item Das Attribut \verb|name| kennen Sie bereits. 
		\item Wenn Sie bei einer Checkbox kein \verb|value|-Attribut programmiert haben, dann wird dem Programm, das über das \verb|action|-Attribut des \verb|<form>| festgelegt wurde die Nachricht \verb|bezeichner=on| übertragen. (Respektive der Name, den Sie programmiert haben.)
		\item Haben Sie dagegen ein Attribut \verb|value| wie oben programmiert, dann wird dem Programm die Nachricht \verb|bezeichner=wert| übermittelt.
	\end{itemize}
	
	\textbf{Wichtig} (ebenfalls erst in Bezug auf Programme, die Nutzereingaben verwalten):\\	
	Wenn eine Checkbox nicht angewählt wird, dann wird keine Nachricht an das Programm weitergemeldet. Das mag jetzt überflüssig klingen, aber nehmen wir an, Sie programmieren eine Liste mit solchen Checkboxen, in denen ein Nutzer angeben soll, welche Zutaten er für ein Rezept bereits zu Hause hat. In diesem Fall würden Sie wahrscheinlich das folgende im Programm festlegen: Computer, erstelle eine Einkaufsliste all der Zutaten, die der Nutzer noch nicht hat. Da das Programm aber nur diejenigen Zutaten übermittelt bekommt, die der Nutzer schon hat, funktioniert das so nicht: Es weiß ja gar nicht, welche Zutaten der Nutzer noch nicht hat.\\

	Deshalb sollten Sie keinesfalls Checkboxen programmieren, bei denen es für die weitere Nutzung wichtig ist, dass eine Meldung an das Programm übertragen wird, wonach sie deaktiviert wurde.\\

	\item Radio Buttons:\\
	\textbf{Quellcode}: \\\verb|<input type=radio name=bezeichner value=wert>|

\end{itemize}

Checkboxen und Radio Buttons verwirren Einsteiger häufig, weil der Unterschied zunächst nicht klar ist. Dabei ist er recht simpel: \\

\begin{itemize}
	\item Checkboxen sind für die Fälle gedacht, in denen Nutzer beliebig viele Optionen anwählen dürfen.\\
	(Denken Sie an einen Bestellservice, bei dem Nutzer beliebig viele Beilagen zu einem Gericht auswählen können.)
	\item Radio Buttons sind dafür gedacht, dass Nutzer sich für eine von vielen Optionen entscheiden müssen.\\
	(Denken Sie hier an ein Reisebüro, bei dem Nutzer sich zwischen erster und zweiter Klasse entscheiden müssen.)
\end{itemize}

Beispiel für einfaches Formular mit Auswahlmöglichkeiten zum An- oder Abwählen:

\begin{verbatim}
	<form>
	Wählen Sie bitte Ihre Beilage:
	<input type=radio name=reis value=reis>Reis
	<input type=radio name=fries value=fries>Pommes Frites
	<input type=radio name=potatoes value=potatoes>
	Kartoffeln
	<form>
\end{verbatim}

Die folgenden Eingabetypen sind Alternativen zu Radio Buttons und \\Checkboxen: Im Gegensatz zu diesen beiden wird bei den folgenden jeweils eine Menüleiste eingeblendet, aus der NutzerInnen Einträge \\auswählen können. Ein Sonderfall ist die Farbpalette, aus der NutzerInnen eine Farbe auswählen können.

\begin{itemize}
	\item Drop-Down-Liste\\
	\textbf{Zweck}: Genau wie Radio-Buttons beschränken Drop-Down-Menüs NutzerInnen darauf, eines von mehreren Angeboten auszuwählen. Der Unterschied besteht darin, dass die Auswahlmöglichkeiten mittels Radio-Buttons vollständig angezeigt werden, während die Optionen (deshalb der Name) einer Drop-Down-Liste nur dann angezeigt werden, wenn Nutzer die Liste angewählt haben.\\	
	\textbf{Quellcode}:\verb|<select>|\\\verb|<option>Beschriftung</option>|\\\verb|<option>...</select>|\\

	Über den \verb|<select>|\index{HTML!Container!select}-Container legen Sie fest, dass eine Drop-Down-Liste angezeigt werden sollen. Für jeden Eintrag müssen Sie einen \verb|<option>|\index{HTML!Container!option}-Container innerhalb des \verb|<select>|-Containerns \\programmieren. Damit Nutzer einen Eintrag angezeigt bekommen, müssen Sie bei jedem \verb|<option>|-Container einen Text als Inhalt programmieren.\\

	Wenn Sie innerhalb eines Drop-Down-Menüs einzelne \verb|<option>|-Container in einem unter-Drop-Down-Menü versammeln wollen, \\können Sie dafür den \verb|<optgroup>|\index{HTML!Container!optgroup}-Container verwenden. Einziger Unterschied gegenüber \verb|<option>|-Containern ist, dass Nutzer durch das Anwählen des \verb|<optgroup>|-Containers noch keine Option \\anwählen. Dieser hat also keinen \verb|value|, sondern sein Name wird über das \verb|label|-Attribut definiert.\\

	Wenn Sie eine \verb|<optgroup>| als nicht anwählbar markieren wollen (z.B. weil der Inhalt noch nicht programmiert ist, dann benutzen Sie dafür das Attribut \verb|disabled|\index{HTML!Attribut!disabled}.\\

	\item Datalist\\
	\textbf{Quellcode}: \verb|<datalist><option><option>...</datalist>|\\
	Eine Datalist sieht zunächst wie ein Textfeld aus, aber über die option-Container erhalten Nutzer gültige Werte angezeigt. Im Gegensatz zur Drop-Down-Liste sind die \verb|<option>|-Container mit dem \verb|value|-Attribut vollständig, es gibt hier also keinen zusätzlichen Container-Inhalt.\\

	\item Farbauswahl:\\
	\textbf{Quellcode}: \verb|<input type=color>|\\
	Damit ermöglichen Sie es Nutzern, eine Farbe aus einer Palette auszuwählen. Das könnte beispielsweise nützlich sein, wenn Spieler eine Farbe für Ihre Spielfiguren auswählen sollen. Wie gewohnt nutzen Sie hier das \verb|name|-Attribut, um die Eingabe an ein Programm zu übergeben. 
\end{itemize}


\subsubsection{Schalter}

Neben den folgenden input types gibt es noch die \verb|<button>|-Container, mit denen Sie dieselben Funktionen realisieren können. Hier lautet meine Empfehlung allerdings, keine \verb|<button>|-Container zu nutzen: Wenn alle Eingabemöglichkeiten als \verb|<input>|-Container programmiert werden, ist es leichter, alle Eingabemöglichkeiten im Code zu finden. (Für den Leistungsnachweis \glqq{}Projekt 1\grqq{} ist die Nutzung von \verb|<button>| deshalb untersagt.

\begin{itemize}
	\item Schalter mit Beschriftung\\	
	Zweck: Damit programmieren Sie einen Schalter, über den eine Funktion des Programms aufgerufen wird, das über das \verb|action|-Attribut des \verb|<form>|-Containers festgelegt wurde. Der Name dieser Funktion wird dem Attribut \verb|onclick| zugeordnet. Was Funktionen sind und wie Sie sie mithilfe des \verb|onclick|-Attributs nutzen können erfahren Sie im Kapitel zur Programmierung in PHP.\\
	\textbf{Quellcode}: \verb|<input type=button value="Beschriftung |\\\verb|auf der Schaltfläche" onclick=function()>|\\
		
	\item Schalter mit Bild\\	
	\textbf{Zweck}: Bei dieser Variante programmieren Sie einen Button, der keinen Text, sondern ein Bild enthält.\\	
	\textbf{Quellcode}: \verb|<input type=image src="URL eines Bildes"|\\\verb| onclick=...>|\\
	
	\textbf{Wichtig}: Da ein Button wieder deaktiviert wird, wenn Nutzer den Mausbutton loslassen, macht die Programmierung eines \verb|name|- und/ oder eines \verb|value|-Attributs hier keinen Sinn. Vielmehr dienen Buttons dazu, dass Nutzer damit bestätigen, dass sie die Eingaben \\tatsächlich abschicken wollen. Für Sie als EntwicklerIn bedeutet dass, dass die Variablen an das Programm übertragen werden, das über das \verb|action|-Attribut des \verb|<form>|-Containers festgelegt wurde.\\
	
	\item Reset-Schalter\\	
	\textbf{Zweck}: Mit diesem Schalter können Nutzer alle Eingaben löschen.\\	
	\textbf{Quellcode}: \verb|<input type=reset>|\\
	
	\item Absende-Schalter\\	
	\textbf{Zweck}: Mit diesem Schalter übergeben Nutzer die Daten zur weiteren Verwendung durch Ihre Webanwendung.\\	
	\textbf{Quellcode}: \verb|<input type=submit>|\\
	
	Im Gegensatz zu \verb|type=button| und \verb|type=image| rufen Sie hier also keine bestimmte Funktion des Programms auf, sondern durch einen Klick auf diesen Schalter werden sämtliche Eingaben des Nutzers an das Programm übergeben.\\
	
	Wichtig: Sie brauchen keine zusätzliche Beschriftung zu programmieren. Das übernimmt der Browser für Sie.\\
	
	Beachten Sie dabei bitte, dass es hier nur um die Eingaben innerhalb eines Formulars geht. Wenn Sie innerhalb eines HTML-Dokuments mehrere \verb|<form>|-Container programmiert haben, benötigen Sie für jeden dieser Container einen \verb|type=submit|. Denn durch diesen werden ausschließlich diejenigen Daten weitergeleitet, die sich im selben \verb|<form>|-Container befinden.
\end{itemize}

\subsection{Container für die Gruppierung und Zuordnung von Eingabeelementen}

Um mehrere Elemente zu gruppieren müssen diese lediglich in einem\\ \verb|<fieldset>|\index{HTML!Container!fieldset}-Container zusammengefasst und durch einen \verb|<br />|-\\Container getrennt werden. \verb|<br>|-Container sind Container ohne Inhalt, die einen Zeilenumbruch bewirken. In HTML5 kann der \verb|/| deshalb auch weggelassen werden. Vor HTML5 waren sie generell sehr wichtig, da sie für die Gestaltung von Belang waren. Aber da das jetzt in CSS geregelt wird, brauchen Sie sie nur noch in seltenen Fällen wie eben der Zeilentrennung innerhalb eines \verb|<fieldset>|.\\

Eine Überschrift für ein \verb|<fieldset>| programmieren Sie nicht mit einem \verb|<h...>|-Container, sondern mit einem \verb|<legend>|\index{HTML!Container!legend}-Container, der im Gegensatz zu den \verb|<h...>|-Containern keine Ziffer enthält: Er \glqq{}heißt\grqq{} immer \verb|<legend>|, nicht legend1, legend2, legend3 usw.. Ansonsten gibt es keine Unterschiede zwischen den beiden.\\

Ein weiterer Container, den Sie benötigen, um Formulare zu programmieren ist der \verb|<label>|-Container. Dieser erzeugt keinen sichtbaren Unterschied, aber er ist wichtig, damit ein Webbrowser z.B. erkennen kann, dass ein Text, der neben einem \verb|<input>|-Container steht als Beschriftung für dieses Eingabefeld gedacht ist. Das wirkt sich ggf. auf die Anzeige aus.\\

An dieser Stelle ist das \verb|id|-Attribut des Containers wichtig, auf den das Label sich beziehen soll. Denn der \verb|<label>|-Container hat an sich noch keine Bindung zu einem anderen Container. Er bekommt die erst, indem das \verb|for|-Attribut genutzt wird: Dieses bekommt als Wert den Wert des \verb|id|-Attributs desjenigen Containers, auf den das Label sich beziehen soll.\\

Hier wäre dann ein typisches Formular, wie Sie es für Nutzerregistrierungen verwenden können:\\

\begin{verbatim}
<form>
<fieldset>
<legend>Bitte geben Sie Ihre persönlichen Daten ein:
</legend>
<label for=surname>Nachname:</label>
<input id=surname name=surname required >
<br>
<label for=email>E-Mail:</label>
<input type=email id=email name=email required >
<br>
<label for=age>Alter:</label>
<input type=number id=age min=0 max=140 name=age 
required >
<br>
<label for=birthdate>Geburtsdatum:</label>
<input type=date id=birthdate name=birthdate 
required >
</fieldset>
<input type=submit>
</form>          
\end{verbatim}

\subsection{Zusammenfassung}

Es gibt in HTML5 deutlich mehr Formularfelder als bei 4.01. Der Grund ist recht einfach: Die neuen Felder prüfen (bis auf \verb|type=text|, \verb|type=button| und ähnliche), ob die Nutzereingabe valide ist. Die Eingabe einer Telefonnummer im Feld für die Eingabe der Mailadresse ist damit ausgeschlossen. Auch unsinnige Eingaben wie der 99. März sind damit unmöglich. Bei HTML4.01 hätten Sie dazu noch umfangreichen Code in PHP bzw. JavaScript programmieren müssen.

\section{Multimediale Inhalte einfügen}

Auch dieser Abschnitt hat sich gegenüber HTML4.01 deutlich geändert. Es gibt vier neue Container, die speziell für die Einbindung von Audio- und Videodateien sowie für ein gutes Layout aller multimedialen Dateien gedacht sind. Der große Unterschied gegenüber HTML4.01 besteht darin, dass Sie jetzt alle Arten von multimedialen Inhalten im Browser abspielen können, ohne dafür ein PHP- oder JavaScript-Programm zu benötigen. Das galt früher nur für Bilder.\\

\textbf{Wichtig}:\\

Wir reden hier momentan ausschließlich über anzeigbare oder abspielbare Inhalte. Interaktive Formate wie Flash aber auch die Programmierung interaktiver Inhalte mit Canvas lassen wir momentan außen vor. \textbf{Canvas}\index{HTML!Canvas} ist ebenfalls eine Neuerung in HTML5, die die Gestaltung von Bildern und Animationen ermöglicht. Sie brauchen hierzu also kein zusätzliches Programm. Canvas geht aber noch weiter, denn mithilfe von JavaScript können Sie darin vollständige interaktive Anwendungen (also auch Spiele) programmieren.

\subsection{Bilder}

Der \verb|<img>|\index{HTML!Container!img}-Container ist der einzige Container für multimediale Inhalte, den es so bereits vor HTML5 gab. Allerdings gilt hier wie überall, dass Attribute, die bei HTML4.01 fürs Layout genutzt wurden nicht mehr unterstützt werden. (Viele Browser unterstützen sie zwar immer noch, aber wenn Sie wollen, dass Ihre Webanwendung dauerhaft nutzbar ist, dann sollten sie diese Regelung für HTML5 beachten.)\\

Um eine Bilddatei einzufügen, nutzen Sie den \verb|<img>|-Container. \verb|<img>|-Container haben keinen Inhalt, denn die Bilddatei, die Sie anzeigen lassen wollen wird als Attribut des Containers programmiert.\\

\begin{itemize}
	\item Das Attribut \verb|src| erhält als Wert die URL an, unter der die Bilddatei zu finden ist.\\	
	\textbf{Bsp}.: \verb|src=bild.jpg|

	\item Das Attribut \verb|alt|\index{HTML!Attribut!alt} gibt einen Alternativtitel an, der so lange angezeigt wird, wie das Bild noch nicht geladen ist. Es ist vor allem für die Barrierefreiheit wichtig.\\	
	\textbf{Bsp}.: \verb|alt="schönes Bild"|

	\item Die Attribute \verb|width|\index{HTML!Attribut!width} und \verb|height|\index{HTML!Attribut!height} geben an, wie breit bzw. hoch das Bild angezeigt werden soll. Sie ordnen hier jedem der beiden eine Zahl zu, die für die jeweilige Größe in Pixeln, also Bildpunkten steht. 

	\textbf{Wichtig}:\\	
	Sie überschreiben mit \verb|width| und \verb|height| damit das Seitenverhältnis des Bildes. Wenn Sie Bilder also für bestimmte Displaygrößen ändern wollen, dann sollten Sie zunächst über ein PHP- oder JavaScript-\\Programm das Seitenverhältnis berechnen und dann anhand dieser Berechnung dort (also im Programm) die Änderung von Höhe und Breite durchführen.
\end{itemize}

\subsection{figure und figcaption}

Wenn Sie ein wissenschaftliches Buch aufschlagen, sehen Sie zu jeder \\ergänzenden Darstellung einen Untertitel. Mit dem \verb|<figcaption>|\index{HTML!Container!figcaption}-\\Container gibt es in HTML5 die Möglichkeit genau dasselbe in standardisierter Form auf einer Webanwendung zu tun. Dieser Container darf allerdings nur innerhalb eines \verb|<figure>|\index{HTML!Container!figure}-Containers verwendet werden.\\

Nun fragen Sie sich vielleicht, was dieser \verb|<figure>|-Container denn soll, wo es doch bereits den \verb|<img>|-Container gibt. Die Antwort ist recht einfach: Dieser Container ist dafür gedacht jede Art von multimedialen Inhalten standardisiert bereitzustellen. Es ist also egal, ob Sie nun ein Bild, ein Video, eine Audiodatei anzeigen bzw. abspielen wollen; immer nutzen Sie die gleiche Kombination aus \verb|<figure>| und \verb|<figcaption>|, deren Aussehen Sie über ein CSS-Skript definieren.\\

Und nicht nur dass: Sie können mit dem \verb|<figure>|-Container auch gleich Kombinationen verschiedener multimedialer Dateien erstellen, die im Sinne des semantic web als solche erkannt werden können. Nehmen wir an, Sie haben im Urlaub mehrere Bilder vom Strand geschossen und zusätzlich Aufnahmen vom Meeresrauschen, aus dem Restaurant und von anderen Stellen aufgenommen. Nun wollen Sie als diese Dateien als eine Diashow mit Sound auf Ihrer Webanwendung platzieren. Dann können Sie genau das über einen \verb|<figure>|-Container erledigen. Und im Gegensatz zu\\ HTML4.01 erkennt jeder HTML5-kompatible Browser, dass es sich bei all diesen einzelnen Dateien um eine logische Einheit (eben Ihre Diashow mit Sound) handelt, obwohl es auf dem Rechner mehrere Dateien sind.\\

Hier ein einfacher \verb|<figure>|-Container:

\begin{verbatim}
<figure>
<img src=hotel01.jpg alt="Ein Bild des Hotels, 
in dem wir die furchtbarsten zwei Wochen 
unseres Lebens hatten.">
<figcaption>Bates Motel</figcaption>
</figure>
\end{verbatim}

\subsection{figcaption für Fortgeschrittene}

Eine \verb|<figcaption>| kann aber nicht nur einen Untertitel enthalten, sondern zusätzlich bzw. unabhängig von einem Text die URL einer Audiodatei. Dann wird das Bild mit dieser Audiodatei akustisch untermalt. Dazu wird ein \verb|<audio>|-Container verwendet. Wie das geht (und das es sehr leicht zu realisieren ist) sehen Sie in Kürze.

\section{Weitere multimediale Formate}

In diesem Abschnitt erfahren Sie, wie Sie die verschiedensten multimedialen Inhalte in Ihre HTML5-Webanwendung einbinden können. Ein Hinweis vorweg: Zwar bringt HTML5 nur für einige Formate eine \\Unterstützung mit, aber Sie erfahren gleich, wie Sie auch andere Formate einbinden können.

\subsection{Einbindung eigener und frei verfügbarer Videodateien}

Die Einbindung von Videodateien ist fast genauso einfach wie die Einbindung von Bildern: Nutzen Sie dazu den \verb|<video>|\index{HTML!Container!video}-Container innerhalb eines \verb|<figure>|-Containers. Der Unterschied besteht nun darin, dass Sie mehrere Videodateien einstellen können, von denen der Webbrowser sich eines aussuchen kann. Das ist deshalb sinnvoll, weil Sie sich so nicht darum kümmern müssen, zu prüfen, welches Videoformat vom jeweiligen Webbrowser abgespielt werden kann. Das bedeutet also, dass Sie sich nicht für ein Format wie \verb|.mp4|, \verb|.mov|, \verb|.wmv| usw. entscheiden müssen, sondern Sie können Sie alle nutzen und es ist sogar ideal, wenn Sie ein Video in möglichst vielen Formaten bereitstellen können.\\

In einem \verb|<video>|-Container können Sie die folgenden Attribute nutzen:

\begin{itemize}
	\item \verb|controls|\index{HTML!Attribut!controls} regelt, welche Bedienelemente angezeigt werden. Die \\Standardeinstellungen bewirken, dass ein Play/Pause-Button, eine Zeitleiste und die aktuelle Zeit im Video angezeigt werden. Wenn Ihnen das nicht genügt oder Sie eine Vielzahl an Formaten abspielen wollen (z.B. Flash), dann können Sie im Netz eine Vielzahl an Playern finden, die Sie direkt in den Quellcode Ihrer Webanwendung einbinden können. Suchen Sie dazu schlicht nach \glqq{}HTML5 Videoplayer\grqq{}.\\
	
	\textbf{Wichtig}: Auch wenn Sie lediglich die Standard-Bedienelemente anzeigen lassen wollen, müssen Sie \verb|controls| als Attribut in den\\ \verb|<figure>|-Container einfügen. Sie brauchen dann aber keinen weiteren Wert zuordnen.
	
	\item Die Attribute \verb|height| und \verb|width| funktionieren wie bei \verb|<img>|-\\Containern. Es gelten die selben Hinweise wie dort.
	
	\item Innerhalb des \verb|<video>|-Containers erstellen Sie für jede Videodatei einen \verb|<source>|-Container. In diesem geben Sie zum einen die URL der jeweiligen Videodatei über das \verb|src|-Attribut und zum anderen das Kompressionsverfahren über das \verb|type|-Attribut an.\\

	\textbf{Kompressionsverfahren}\index{Kompression} dienen dazu, um aus einer großen Audio- oder Video-Datei eine kleinere Datei zu erstellen. Ob das zu sichtbaren Qualitätsverlusten führt, hängt vom Verfahren ab. Das bekannteste Kompressionsverfahren für Audio-Dateien ist unter der Abkürzung mp3 bekannt.\\

	\item \textbf{Wichtig}: Nichts ist für einen Nutzer ärgerlicher als wenn er nicht weiß, warum etwas nicht funktioniert. Deshalb können Sie als letzten Eintrag im \verb|<video>|-Container einen Text eintragen, der ausgegeben wird, wenn der Webbrowser keines der Formate abspielen kann.\\
\end{itemize}

\begin{verbatim}
<figure controls>

<video alt="Video über die Herstellung von Büchern">

<source src=movie.mp4 type=video/mp4>
<source src=movie.ogg type=video/ogg>
Leider kann Ihr Browser keines der Formate abspielen, 
in dem die Videodatei vorliegt. Bitte prüfen Sie, ob 
Sie eine Erweiterung installieren können, mit dem Sie 
eines der folgenden Formate abspielen können: 
MP4, Vorbis OGG

</video>

<figcaption>
Quelle: <a href=http://www.irgendeineseite.de>
www.irgendeineseite.de</a>
</figcaption>

</figure>
\end{verbatim}

\subsection{Anpassungsmöglichkeiten für den Video-Player}

Sie wissen, dass Webanwendung von den verschiedensten Endgeräten aus aufgerufen werden: Manche User nutzen ein Smartphone mit einer langsamen Internetverbindung, andere nutzen einen Rechner, der per Kabelanschluss Daten mit bis zum 15 MB/s (entspricht ungefähr einem 100 mbps-Anschluss) herunterladen kann. Es wäre also ungeschickt, wenn Sie auf einer Webanwendung ein Dutzend Videos platzieren und den Webbrowser anweisen, alle vollständig herunterzuladen, egal ob der Nutzer sie nun sehen will oder nicht. Deshalb können Sie das Verhalten des Videoplayers anpassen, indem Sie die folgenden Attribute bzw. Attributbelegungen in den \verb|<video>|-Container einprogrammieren:

\begin{itemize}
	\item \verb|preload=none|\index{HTML!Attribut!preload}\\		
	Diese Attributbelegung bewirkt, dass der NutzerInnen einen kleinen Platzhalter sehen, der lediglich anzeigt, dass eine Video-Datei zur Verfügung steht. Die Datei selbst wird nicht heruntergeladen, bis NutzerInnen sie anforderen. Diese Option ist gut geeignet, wenn Sie eine Webanwendung mit vielen Videos programmieren wollen, die auch mit einem Smartphone noch übersichtlich sein soll.
	
	\item \verb|preload=metadata|\\	
	Diese Attributbelegung bewirkt, dass NutzerInnen einen Platzhalter sehen, der im Gegensatz zu \verb|preload=none| auf der Webanwendung so groß angezeigt wird, wie das Video selbst. Das Video wird auch in diesem Fall nicht heruntergeladen, bis NutzerInnen es anfordern. Diese Option ist vor allem für Rechner gut geeignet, wenn auf einer Seite viele Videos platziert werden. Denn selbst bei durchschnittlichen DSL-Anschlüssen kann es sonst mehrere Minuten dauern, bis alle Inhalte einer einzelnen Seite herunter geladen sind. Der Vorteil dieser \verb|preload|-Belegung besteht darin, dass sich das Layout der Seite nicht ändert, wenn Nutzer Videos starten.
	
	\item \verb|autoplay|\index{HTML!Attribut!autoplay}\\	
	dürfte selbsterklärend sein: Das Video wird automatisch gestartet, wenn NutzerInnen die Seite öffnen, auf der es eingebunden ist. Dieses Attribut macht in Verbindung mit den beiden eben vorgestellten \verb|preload|-Varianten natürlich keinen Sinn. Dieses Attribut sollten Sie keinesfalls bei multimedialen Dateien verwenden, die eine Audio-Komponente haben, denn im schlimmsten Fall schließen Nutzer Ihre Webanwendung schlicht deshalb, weil sie sich von der Tonspur gestört fühlen.
	
	\item \verb|loop|\index{HTML!Attribut!loop}\\	
	Wurde das Video einmal gestartet, bewirkt dieses Attribut, dass es immer wieder von vorne beginnt. Das ist vor allem dann sinnvoll, wenn Sie ein Video anstelle eines Bildes in den Hintergrund einer Webanwendung einblenden wollen. Sie können dieses Attribut also mit autoplay kombinieren, wenn Sie ein Video anstelle eines Bildes im Hintergrund einer Seite abspielen wollen.
	
	\item \verb|poster|\index{HTML!Attribut!poster}\\	
	Wird dieses Attribut ohne weitere Zuordnung verwendet, dann wird der erste Frame (quasi das erste Bild) des Videos als Stellvertreter angezeigt. Das macht in Verbindung mit \verb|preload=none| natürlich keinen Sinn.
	
	Als Wert kann diesem Attribut die URL einer Bilddatei zugeordnet werden. Dann wird dieses Bild als Stellvertreter des Videos angezeigt, bis es gestartet wird.
\end{itemize}

\subsubsection{Aufgabe}

Finden Sie zwei Einsatzmöglichkeiten für \verb|poster| mit einem Wert \\gebraucht und missbraucht werden kann.

\subsection{Einbindung von geschützten Inhalten (Stichwort: DRM)}

Mit den beschriebenen Möglichkeiten können Sie Videodateien einbinden, auf die Sie freien Zugriff haben. Aber wie Sie wissen ist das beispielsweise bei Videos auf YouTube nicht der Fall. Wenn Sie sicher sind, dass Sie das Recht dazu haben, dann dürfen Sie solche Videos mit einem \verb|<iframe>|\index{HTML!Container!iframe}-Container einbinden. Da hier bis auf \verb|allowfullscreen|\index{HTML!Attribut!allowfullscreen} keine neuen Attribute vorkommen, sollten Sie das folgende Codefragment ohne weitere Erklärungen einbinden können:\\

\verb|<iframe src=http://www.youtube.de/...|\\\verb|allowfullscreen />|

\subsection{Der audio-Container}

Alles, was Sie beim \verb|<video>|-Container nutzen können und das bei einer Audio-Datei Sinn macht, können Sie genau so bei einem \verb|<audio>|\index{HTML!Container!audio}-Container nutzen. Kommen wir also zu den Unterschieden gegenüber einem \verb|<video>|-Container:

\begin{itemize}
	\item Ein \verb|<audio>|-Container hat in aller Regel kein Bild, also gibt es für den Nutzer keinen sichtbaren Unterschied zwischen den Attributbelegungen \verb|prelaod=none| und \verb|preload=meta|.
	\item Wenn Sie ein Bild zu einer Audiodatei anzeigen wollen (oder eine Diashow), dann nutzen Sie dazu das Verfahren, auf das bei der Erklärung zur \verb|<figcaption>| hingewiesen wurde.
	\item Dem \verb|type|-Attribut müssen Sie natürlich audio-Typen zuordnen.\\
	\textbf{Bsp}.: \verb|type=audio/mp3|
	\item Das gilt auch dann, wenn ein Type sowohl für Audio- als auch für Video-Dateien existiert.\\
	\textbf{Bsp}.: Das Kompressionsverfahren OGG ist für Audio- und Videoverfahren definiert. Also müssen Sie hier je nach Medienformat \verb|type=video/ogg| oder \verb|type=audio/ogg| angeben.
\end{itemize}

\subsection{Close Captions, Untertitel, Einbindung von Webcams usw.}

Neben den genannten Möglichkeiten gibt es aber auch noch Dinge wie Untertitel oder Texteinblendungen für Menschen mit beschränktem Hör-vermögen. Wir werden diese Möglichkeiten nicht im Rahmen der Veranstaltung behandeln. Wenn Sie hieran interessiert sind, möchte ich Sie auf das Format WebVTT hinweisen, das Ihnen in diesen Fällen eine Vielzahl praktischer Erweiterungen für Ihre Webanwendung anbietet.\\

Ähnliches gilt für die Nutzung von Webcams, Mikrophonen und anderen Eingabemöglichkeiten für den Nutzer: Alles, was über die Nutzung von Tastatur und Maus hinausgeht ist nicht Teil dieser Veranstaltung. Hier sollten Sie bei Interesse nach dem Begriff getUserMedia suchen.\\

Grundsätzlich sollten Sie jedoch zunächst HTML, CSS und JavaScript beherrschen, bevor Sie sich in diese Bereiche einarbeiten.

\subsection{Hinweis bezüglich Flash und ähnlichen Formaten}

Adobes \textbf{Flash}\index{Programmiersprache!Flash} bzw. Shockwave war über Jahre hinweg der Standard, wenn es um das Entwickeln von interaktiven Elementen bzw. Spielen auf einer Webanwendung ging. \textbf{JavaScript}\index{Programmiersprache!JavaScript} bot hier zu wenige Möglichkeiten und einzig \textbf{Java}\index{Programmiersprache!Java} wurde so entwickelt, dass es im Browser nutzbar war. Warum die meisten Entwickler Flash nutzten soll uns an dieser Stelle nicht interessieren; Tatsache ist, dass es den de-facto-Standard für Webanwendungen darstellte. Wie schon oben angesprochen ändert sich das gerade, was nicht zuletzt daran liegen dürfte, dass JavaScript als Standardsprache für HTML5 festgelegt wurde. \\

Wenn Sie nun Flash-Anwendungen auf Ihrer Seite anbieten wollen, müssen Sie aus diesem Grund einen HTML5-Flash-Player integrieren. Danach suchen Sie genau wie nach HTML5-Video-Playern. Auch die Einbindung funktioniert wieder so ähnlich wie dort. Aber auch hier gilt wieder, dass das kein Thema dieser Veranstaltung ist, sondern lediglich eine Zusatzinformation für interessierte Leser.\\

Ein weiterer Nachteil von Flash besteht darin, dass Flash im Gegensatz zu den multimedialen Containern von HTML5 nicht per CSS angepasst werden kann. Neben dem Nachteil, dass Flash-Inhalte somit schwieriger ans Layout der Seite anzupassen sind, folgt daraus, dass sie im Regelfall nicht barrierefrei sind.

\subsection{Hausaufgabe}

Kommen wir jetzt zur Datei \verb|index.html|, die Sie zwar in Ihrem Projektordner haben, die aber bislang leer ist. Damit dies eine Startseite für Ihre Webanwendung wird und Sie zwischen den einzelnen Seiten hin- und herwechseln können, programmieren Sie bitte folgendes: (Wenn nicht anders geschrieben programmieren Sie es bitte in der \verb|index.html|.)

\begin{itemize}
	\item Fügen Sie die Strukturelemente hinzu, die Sie für HTML5-Seiten kennen gelernt haben.
	\item Internationalisieren und Lokalisieren Sie die Seite.
	\item Erstellen Sie ein Log-In-Formular im \verb|aside|-Container.
	\item Erstellen Sie eine neue Seite mit einem Registrieren-Formular, sodass Sie Nutzern später die Möglichkeit geben, sich zu registrieren. 
	\item Erstellen Sie eine Zusammenfassung der geplanten und vorhandenen Inhalte Ihrer Webanwendung im \verb|main|-Container.
	\item Verlinken Sie an den passenden Stellen auf die entsprechenden Unterseiten.
	\item Programmieren Sie umgekehrt auf allen bisherigen Seiten Links. Nutzer müssen mindestens die Möglichkeit haben, über einen Link wieder auf die Startseite zurück zu kommen.
	\item Nehmen Sie Bilder, Videos und Audio-Dateien auf, die zu einzelnen Passagen auf Ihrer Webanwendung passen und stellen Sie diese auf Ihrer Webanwendung ein.
	\item Achten Sie darauf, dass bezüglich der Barrierefreiheit zumindest die drei Punkte beachtet werden, die Sie oben kennen gelernt haben.
	\item Erstellen Sie zu wenigstens einer Ihrer Seiten eine Umfrage, bei der Sie auch verschiedene Auswahlmöglichkeiten programmieren.
	\item Nicht vergessen: Prüfen Sie, ob Sie für Firefox, Safari, IE oder Edge Polyfills nutzen müssen.
\end{itemize}

\section{Weitere Formatierungen und Möglichkeiten in HTML}

Wie es die Überschrift schon sagt finden Sie hier eine Reihe weiterer \\Möglichkeiten, um Inhalte auf Ihrer Webanwendung zu programmieren bzw. um die Inhalte genauer zu definieren. Die folgenden Abschnitte haben keine feste Reihenfolge, sondern sollen Ihnen lediglich einen Einblick geben, was Sie in HTML5 (zum Teil aber auch schon in HTML4.01) noch an Möglichkeiten haben:

\subsection{Spoiler und andere ausklappbare Texte}

Kennen Sie das? Sie sitzen mit Freunden zusammen und einer davon\\ erzählt das Ende eines Filmes, den Sie noch sehen wollten. So etwas wird mit dem englischen Begriff Spoiler bezeichnet und um jemanden zu warnen, dass gleich ein Spoiler kommt, gibt es den Begriff Spoiler Alarm.\\

Nun nehmen wir an, Sie wollen Filmrezensionen auf Ihrer Webanwendung veröffentlichen, wollen aber dass Ihre Leser selbst entscheiden können, ob Sie die Spoiler mitlesen wollen oder nicht. In HTML5 ist das kein Problem. Nun gibt es aber keinen spoiler-Container, sondern Sie benutzen für solche Fälle zwei Container:

\begin{itemize}
	\item Der \verb|<summary>|\index{HTML!Container!summary}-Container enthält eine kurze Beschreibung dessen, worum es geht. \\	
	\textbf{Bsp}.: Sie erstellen eine Webanwendung über die Geschichte Kroatiens. Im laufenden Text wollen Sie etwas über den Geburtsort des amtierenden Präsidenten schreiben. Andererseits sind Sie nicht sicher, ob das die meisten Leser interessiert. Also erstellen Sie den folgenden Container:
	
	\verb|<summary>Über den Geburtsort des kroatischen|\\\verb|Präsidenten</summary>|
	
	\item Anschließend ergänzen Sie nach dem Wort Präsidenten (oder an anderer Stelle innerhalb des \verb|<summary>|-Containers noch einen \verb|<details>|\index{HTML!Container!details}-Container, in dem Sie all das über den besagten Geburtsort schreiben, was Sie für interessant halten.\\	
	Hier ein Beispiel für den oben genannten Spoiler-Fall:
	
	\begin{verbatim}
		<summary>Das Ende von Hamlet
		<details>Alle sind tot.</details>
		</summary>
	\end{verbatim}
	
\end{itemize}

Wenn Sie innerhalb des \glqq{}Spoilers\grqq{} noch weitere Spoiler unterbringen wollen ist das kein Problem; ähnlich wie bei \verb|<article>| und \verb|<section>| können Sie \verb|<summary>| und \verb|<details>| beliebig komplex verschachteln. Dabei müssen Sie lediglich darauf achten, dass der äußerste Container ein \verb|<summary>| ist, und dass Sie die Container jeweils im Wechsel nutze\\n müssen.\\

Sprich: Sie dürfen zwar innerhalb eines \verb|<summary>| mehrere \verb|<details>|-Container programmieren, aber keinen weiteren \verb|<summary>|. Den müssten Sie dann wieder innerhalb eines der \verb|<details>| programmieren. Umgekehrt gilt das selbe.\\

Natürlich müssen Sie auch bei diesen Containern prüfen, ob Sie inzwischen in allen Webbrowsern unterstützt werden und ggf. ein passendes Polyfill einbinden.

\subsection{Zeitangaben}

\textbf{Wichtig}:\\

Bitte beachten Sie, dass es sich bei dem gleich vorgestellten Container um einen Container handelt, den Sie im Gegensatz zu Formularcontainern wie \verb|<input type=datetime>| und ähnlichen \verb|input|-Containern an beliebigen Stellen innerhalb eines \verb|<body>|-Containers nutzen können. (Zur Erinnerung: \verb|input|-Container bieten NutzerInnen die Möglichkeit, Eingaben durchzuführen.)\\

Bitte beachten Sie ebenfalls, dass der \verb|<time>|-Container keine Ausgabe im Browser erzeugt, sondern einzig dafür sorgt, dass ein Teil des Dokuments einen Zeitstempel erhält. Das bedeutet, dass ein Browser hier direkt erkennen kann, dass ein bestimmter Bereich etwas mit einem bestimmten Zeitpunkt zu tun hat. Wenn also die EntwicklerInnen des Browsers den \verb|<time>|-Container richtig auswerten lassen, dann können Nutzer sich einen Termin direkt aus einer Webanwendung in den eigenen Terminkalender eintragen lassen, ohne dass Sie als EntwicklerIn der Webanwendung dafür etwas programmieren müssten.\\

Mit dem \verb|<time>|-Container können Sie also Zeitangaben und Zeiträume im Sinne des semantic Web definieren. Leider ist es nicht möglich, dass damit alle möglichen Zeitangaben darstellbar wären, denn im Kern wird hierdurch ein Element definiert, dass einen Zeitpunkt oder einen in Sekunden messbaren Zeitraum festlegt. Genau wie bei den entsprechenden \verb|input|-Containern haben Sie also keine Möglichkeit, einen Zeitraum mithilfe eines einzelnen Containers zu programmieren.\\

\textbf{Zur Erklärung:}\\

Da eine Zeitangabe wie die vom 20. Februar bis zum 3. März nicht eindeutig ist (denken Sie an Schaltjahre, bei denen es einen 29. Februar gibt), gibt es auch keinen einzelnen \verb|<time>|\index{HTML!Container!time}-Container, mit dem Sie diesen Zeitraum zusammen fassen können. Aus dem gleichen Grund können Sie Zeiträume nicht in Monaten oder Jahren festlegen; in solchen Fällen müssen Sie zwei \verb|<time>|-Container programmieren, den einen für den Anfang, den anderen für das Ende des Zeitraums. Sie haben hier zwar die Möglichkeit, die Dauer als eigenständigen Container einzuprogrammieren, aber da Sie den Zeitraum explizit angeben müssen, könnten Sie hier einen Fehler einprogrammieren, der für NutzerInnen ärgerlich wäre.\\

So viel zum Negativen, kommen wir jetzt zur praktischen Anwendung von \verb|<time>|:

\begin{itemize}
	\item \verb|<time>|-Container können beliebige Inhalte haben, können aber auch ohne Inhalt als \verb|<time />| beendet werden.
	\item Um Zeitpunkte oder Zeiträume zu definieren wird unabhängig vom Inhalte des Containers das \verb|datetime|\index{HTML!Attribut!datetime}-Attribut verwendet. Für dieses gibt es eine Vielzahl ein Möglichkeiten, Werte zuzuordnen:
	\begin{itemize}
		\item Hier die Varianten für Zeitpunkte:
		\begin{itemize}
			\item Für Jahre:\\
			Eine vierstellige Zahl\\
			\verb|datetime=1905|
			\item Für Jahr und Monat:\\
			Eine vierstellige Zahl, ein Bindestrich, eine zweistellige Zahl\\
			\verb|datetime=2107-03| für März 2107
			\item Für ein Datum ohne Uhrzeit:\\
			Zusätzlich eine weitere zweistellige Zahl, verbunden per \\Bindestrich\\
			\verb|datetime=2015-09-15| für den 15. September 2015
			\item Für Monat und Tag:\\
			Zwei zweistellige Zahlen, verbunden durch einen \\Bindestrich.\\
			\verb|datetime=12-08| für den 8. Dezember
		\end{itemize}
		\item Für die Uhrzeit gibt es mehrere Varianten:
		\begin{itemize}
			\item Zeitpunkt ohne Angabe der Zeitzone:\\
			\verb|datetime=17:22|
			\item Zeitpunkt für GMT:
			\verb|datetime=22:13Z| (Hiweis: Richtig gesehen: Einzig durch das \verb|Z| am Ende des Wertes wird hier eine Uhrzeit als Zeitpunkt nach GMT festgelegt.)
			\item Zeitpunkt für eine andere Zeitzone:\\
			\verb|datetime=02:18-05| (Für GMT - 5)\\
			\verb|datetime=14:47+5:30|	(für GMT + 5½)
			\item Datum und Uhrzeit können verbunden werden, indem \\zunächst das Datum, dann nach einer Leerstelle die Uhrzeit aufgeführt wird:\\
			\verb|datetime="2017-07-21 20:15-7"| (für 20.15 Uhr in der Zeitzone GMT-7 am 21. Juli 2017)
		\end{itemize}
	\end{itemize}
\end{itemize}

Wie oben beschrieben können Sie eine Angabe wie \glqq{}Vom 2. bis 7. März\grqq{} nicht direkt als einen Container programmieren. Aber Sie können die Dauer eines Termins als einen Container programmieren:

\begin{itemize}
	\item \verb|datetime=P30M| entspricht einem Zeitraum von 30 Minuten.
	\item \verb|datetime="P5D 20M 7S"| entspricht einem Zeitraum von 5 Tagen, 20 Minuten und 7 Sekunden.
	\item Wie oben aufgeführt können keine Zeiträume in Monaten oder Jahren definiert werden.
\end{itemize}

Hier noch ein paar Beispiele für \verb|<time>|-Container in HTML:

\begin{itemize}
	\item Die Veranstaltung dauert voraussichtlich\\\verb|<time datetime="P5D 20M 7s">| mehr als 5 Stunden 20 \\Minuten\verb|</time>|.
	\item Der erste Termin findet am \\\verb|<time datetime="2015-09-14 13:00Z">|\\14. September 2015 um 13 Uhr\verb|</time>| statt.
	\item Veranstaltungen finden vom \verb|<time datetime=2015-09-15>|\\15. September\verb|</time>| bis zum \verb|<time datetime=2016-02-03>| 3. Februar\verb|</time>| statt.
\end{itemize}

\subsection{Hervorhebung von Texten}

Bei HTML4.01 wurden Textpassagen meist mit Fettdruck, Unterstreichungen oder Kursivschrift hervorgehoben. Die entsprechenden nicht-\\semantischen Container lauten schlicht \verb|<b>| oder \verb|<strong>| für Fettdruck, \verb|<u>| für unterstrichen und \verb|<i>| (Englisch für italic bzw. kursiv). \\

Diese können weiterhin verwendet werden. Alle drei haben jedoch Nachteile, wenn die Seite von Personen mit eingeschränktem Sehvermögen genutzt werden oder das Display veraltet ist. Außerdem werden Hyperlinks in Webbrowsern in aller Regel als unterstrichener Text präsentiert.\\

Deshalb bietet HTML5 den \verb|<mark>|-Container, dessen \glqq{}Attribute\grqq{} \\\verb|background-color| und \verb|color| per CSS angepasst werden können. \\

Bei allen vier Containern müssen Sie also lediglich eine Textpassage, die Ihnen wichtig erscheint mit dem öffnenden und schließenden Tag des jeweiligen Conatainers umschließen.

\subsection{Unterdrückung von Übersetzungen für Textpassagen}

Aktuelle Browser bieten häufig die Übersetzung von Webanwendung aus anderen Sprachen an. Dazu ist das lang-Attribut des \verb|<html>|-Containers ein wichtiger Hinweis. Doch wenn Sie wollen, dass bestimmte Stellen nicht übersetzt werden sollen, dann können Sie diese durch das Attribut \\\verb|translate=no| von der Übersetzung ausschließen.\\

Wenn das nur für einzelne Wörter gilt (z.B. bei Eigennamen wie Müller oder Excel), dann können Sie den \verb|<span>|-Container verwenden: Dieser ändert die Formatierung des Inhalts zunächst nicht und kann genutzt werden, um beliebig wenige Zeichen innerhalb anderer Container abzugrenzen:

\begin{verbatim}
	<p> 
	... 
	<span translate=no>Tony Marshall</span> sang während 
	<span translate=no>Andy Müller</span> ein Tor schoss. 
	...
	</p>
\end{verbatim}

\subsubsection{Vererbung von Attributen}

Wichtig: Attribute gelten für den gesamten Bereich eines Containers, also auch für alle Container, die sich darin befinden. Dieses Konzept werden Sie in umfangreicherer Form kennen lernen, wenn Sie einen Kurs zur objektorientierten Programmierung belegen.\\

Im folgenden Quellcode haben wir solch einen Fall: Das Attribut\\ \verb|translate=no| wird für den äußeren \verb|<article>|-Container deklariert. Damit gilt das Übersetzungsverbot auch in allen Containern, die sich innerhalb dieses \verb|<article>|-Containers gelten:

\begin{verbatim}
	<article translate=no>
	(Einleitender Text) ...
	<section> ... Sein Vater war von Beruf Müller.
	</section>
	(Noch mehr Text)
	</article>
\end{verbatim}

In diesem Fall würde der gesamte Satz \glqq{}Sein Vater war von Beruf Müller.\grqq{} nicht übersetzt werden.\\

Aber Sie können innerhalb von Containern weitere Container programmieren, in denen Attribute überschrieben werden. Stellen wir uns dazu vor, Sie wollen auf Ihrer Webanwendung einen latainischen Text im Original veröffentlichen und einige Kommentare dazu posten. Dann möchten Sie natürlich nicht, dass die lateinischen Passagen übersetzt werden, während das bei den Kommentaren sinnvoll wäre. Hier ein entsprechender Quellcode:

\begin{verbatim}
	<article translate=no id="Carmina Burana mit Kommentar">
	<p> (Originaltext) <span translate=yes>An dieser Stelle 
	scheint im Text von ... ein Übersetzungsfehler 
	vorzukommen, denn ... </span> ... (Fortsetzung des 
	Originaltexts) ... </p>
	</article>
\end{verbatim}

Der \glqq{}Originaltext\grqq{} und die \glqq{}Fortsetzung des Originaltexts\grqq{} werden beiden nicht übersetzt, weil Sie Teil des \verb|<article>|-Containers sind, für den die Übersetzung mittels des \verb|translate=no| Attributs unterdrückt wird.\\

Dagegen wird der Text \glqq{}An dieser Stelle ...\grqq{} übersetzt, weil er Teil des \verb|<span>|-Containers ist, für den die Übersetzung mittels des \\\verb|translate=yes| Attributs explizit erlaubt wird.\\

Hier sei nochmal darauf hingewiesen: Das \verb|translate=yes| Attribut gilt nur innerhalb des \verb|<span>|-Containers. Anschließend gilt es dann nicht mehr. 

\subsection{Aufzählungen (Ordered und Unordered Lists)}\index{HTML!ordered list}\index{HTML!unordered list}\index{HTML!Container!ul}\index{HTML!Container!ol}\index{HTML!Container!li}

Wenn Sie eine Aufzählung von Elementen erstellen wollen, wie Einkaufslisten, To Do Listen oder ähnliches dann wird das in HTML als unordered List \verb|<ul>| bezeichnet. \\

Wollen Sie dagegen eine Liste erstellen, bei der die einzelnen Einträge z.B. nummeriert sind, um die Reihenfolge anzugeben, dann wird das in HTML als ordered list \verb|<ol>| bezeichnet. Wenn Sie die Art der Nummerierung ändern wollen (z.B. in Großbuchstaben statt Zahlen), dann können Sie dazu das \verb|type|-Attribut nutzen.\\

Die einzelnen Einträge werden dann als \verb|<li>|-Container innerhalb eines \verb|<ul>|- oder \verb|<ol>|-Containers programmiert. Wenn Sie also zwischen einer ordered list und einer unordered list wechseln wollen, müssen Sie nur einen Buchstaben im öffnenden und im schließenden Tag ändern, der Rest bleibt gleich:

\begin{verbatim}
	<ol>
	<li>Michael Schumacher</li>
	<li>Damon Hill</li>
	<li>Jacques Villeneuve</li>
	</ol>
	
	<ul>
	<li>5g Hefe</li>
	<li>3 Eier</li>
	<100ml Wasser</li>
	</ul>
\end{verbatim}

\subsection{Glossare (Description Lists)}\index{HTML!Description List}\index{HTML!Container!dl}\index{HTML!Container!dd}\index{HTML!Container!dt|}

Manchmal benötigen Sie dagegen eine Listenform, bei der Sie Begriffe und Ihre Bedeutung aufzählen wollen. In dem Fall sind \verb|<ul>| und \verb|<ol>| nicht geeignet. Hier greifen Sie am besten auf eine description list \verb|<dl>| zurück.\\

Innerhalb des \verb|<dl>|-Containers verwenden Sie dann einen description title \verb|<dt>|-Container, um den Namen des Eintrags festzulegen und anschließend einen description description \verb|<dd>|-Container, um die Erklärung einzuprogrammieren: (Ob das dd tatsächlich für ein doppeltes description steht, ist nicht sicher, eine Erklärung konnte ich leider nicht finden.)
\begin{verbatim}
	<dl>
	<dt>Kaffee, schwarz</dt>
	<dd>Heißes Getränk, koffeinhaltig, häufig im Becher 
	von Herrn Alpers zu finden.</dd>
	<dt>Bohnesuppe</dt>
	<dd>Kohlenhydrathaltiges Gericht, häufig in Italo-
	Western von Bud Spencer konsumiert.</dd>
	</dl>
\end{verbatim}

\subsection{Tabellen (table)}\index{HTML!Tabelle}\index{HTML!Container!table}\index{HTML!Container!tr}\index{HTML!Container!td}\index{HTML!Container!th}

Tabellen sind einer der wenigen Container, mit denen Sie auch unter HTML5 ohne CSS das Layout einer Seite festlegen können. Diese sollten Sie aber aufgrund der vielen verschiedenen Displaygrößen von Endgeräten nur dann einsetzen, wenn es sich nicht vermeiden lässt. In dem Fall sollten Sie auf jeden Fall per PHP, JavaScript oder mittels einer anderen Sprache die Größe der Tabelle dynamisch anpassen.\\

Eine Tabelle definieren Sie durch einen \verb|<table>|-Container. Für jede Zeile definieren Sie darin einen table row \verb|<tr>|-Container, in dem Sie für jede Spalte einen \verb|<td>|-Container programmieren.\\

Wenn Sie eine Spaltenüberschrift vergeben wollen, verwenden Sie anstelle des <td>-Containers einen table header \verb|<th>|-Container.\\

Der folgende Quellcode soll Ihnen verdeutlichen, warum es wichtig ist, Quellcode übersichtlich zu programmieren, so wie Sie das bei den bisherigen Codebeispielen gesehen haben, denn hier ist das eindeutig nicht der Fall: Benutzen Sie dazu Zeileneinzüge (Tabulatoren) und Zeilenumrüche (Enter Taste).\\

\verb|<table><tr><th>Uhrzeit</th><th>Montag</th><th>Dienstag|\\\verb|</th><th>Mittwoch</th><th>Donnerstag</th><th>Freitag|\\\verb|</th></tr><tr><td>8.30-10.00</td><td>PRG</td>|\\\verb|...</tr>...</table>|

\subsection{Microdata}\index{Microdata}\index{semantic web}

Microdata sind zwar eine zentrale Säule des semantic Web, aber aufgrund des Umfangs dieser Veranstaltung können wir sie uns nur sehr kurz ansehen.\\

Zur Erinnerung: Microdata haben nichts mit der Darstellung oder der Struktur einer Webanwendung zu tun, sondern Sie dienen dazu, dem Browser anzuzeigen, welche Bedeutung einzelne Elemente der Seite haben. Hier ein paar Anwendungsfälle:\\

\begin{itemize}
	\item Der Browser soll eine Adresse ohne weitere Programmierung an eine Anwendung wie google maps weiterleiten können.
	\item Sie wollen, dass der Browser einen Termin in den Kalender Ihres Mail-Programms übertragen kann.
	\item Sie veranstalten ein Event, erstellen eine Webanwendung dazu und wollen, dass eine Suchmaschine erkennt, dass es sich um ein Event handelt.
\end{itemize}

All diese Fälle und noch wesentlich werden bislang unter Begriffen wie \textbf{search engine optimization}\index{search engine optimization} (kurz \textbf{SEO}\index{SEO}) und \textbf{machine-readable content}\index{machine-readable content} zusammen gefasst. Microdata sind ein Mittel, das in HTML5 unterstützt wird, um diese Fälle zu lösen.

\subsubsection{Programmierung von Microdata}

Dazu müssen Sie als erstes einen Container mit dem Attribut \verb|itemscope|\index{HTML!Attrubute!itemscope} deklarieren. Dieses Attribut ändert wie geschrieben nichts an einer Webanwendung, sondern er teilt dem Webbrowser mit, dass es in diesem Container Elemente im Sinne des semantic web geben kann.\\

Für diejenigen, die bereits ein wenig Erfahrung mit der objektorientierten Programmierung haben: Damit deklarieren Sie diesen Container explizit zu einem Objekt, das Sie in einer Sprache wie JavaScript wie ein vollwertiges Objekt verwenden können.\\

Für alle anderen: Ein Objekt im Sinne der klassenbasierten objektorientierten Programmierung besteht im Grunde aus folgenden abstrakten Bestandteilen:

\begin{itemize}
	\item Einem Namen oder Bezeichner, der für jedes Objekt individuell sein muss.\\
	Die Lösung in HTML kennen Sie bereits; es ist das \verb|id|-Attribut. Sie brauchen aber vorerst keine \verb|id|-Attribute zu vergeben, weil wir an dieser Stelle nur Microdata programmieren. Die Änderung von Microdata können Sie durch eine Programmiersprache wie PHP oder JavaScript durchführen.

	\item Einer beliebigen Anzahl an Eigenschaften, die bei unterschiedlichen Objekten des gleichen Typs unterschiedlich ausgeprägt sein können.
	Damit beschäftigen wir uns gleich. Hier ein Beispiel: Eigenschaften können z.B. Telefonnummern sein. Und dass unterschiedliche Elemente unterschiedlich ausgeprägt sein können, bedeutet bei Elementen vom Datentyp Telefonnummer nicht anderes, als dass unterschiedliche Telefonnummern schlicht unterschiedliche Zahlenkombinationen sind.

	\item Einer Datenstruktur oder einem Datentyp, die für jede Eigenschaft individuell beschreibt, um was für eine Eigenschaft es sich handelt.
	Das klingt schwieriger, als es ist; in HTML bedeutet es nur, dass wir damit sagen, dass ein bestimmter Text der Name eines Ansprechpartners ist, dass ein anderer Text seine Anschrift ist, usw.

	\item Einer beliebigen Anzahl an Methoden (alte Bezeichnung: Funktionen), mit denen die Eigenschaften geändert werden können.
\end{itemize}

In HTML haben Sie keinen Zugriff auf Methoden. Diese sind Teil von Programmiersprachen wie JavaScript. Dementsprechend beschäftigen wir uns damit vorerst nicht.

\subsubsection{Festlegung des Objekttyps}

Gerade haben Sie gelernt, dass Sie das Attribut \verb|itemscope| verwenden müssen, um festzulegen, dass ein Container Microdata enthalten soll.\\

Dann müssen Sie festlegen, welche Art von Microdata das sein soll. Zwar könnten Sie hier auch willkürlich eigene Typen festlegen, aber damit hätten Sie die Idee der Microdata ad absurdum geführt, denn was Sie sich bei eigenen Typen denken, kann kein Webbrowser wissen, also wäre es weitestgehend zwecklos, so vorzugehen.\\

Auf der Seite \url{http://schema.org/docs/schemas.html} können Sie eine Vielzahl an sogenannten \textbf{Schemata}\index{Schemata} (das sind unsere Objekttypen) nachschlagen.\\

Wenn Sie nun eine Schema gefunden haben, dass Ihnen gefällt, dann programmieren Sie es mit dem Attribut \verb|itemtype|\index{HTML!Attribute!itemtype} in den entsprechenden Container. Im folgenden Beispiel haben wir das Schema für eine Person verwendet, die u.a. Möglichkeiten anbietet, um eine Anschrift als Microdata zu programmieren:

\begin{verbatim}
	<p itemscope itemtype=http://schema.org/Person>
	</p>
\end{verbatim}

Wie Sie sehen haben wir hier noch keinerlei Angaben zur Person selbst einprogrammiert. Dieser Container würde auf einer Webanwendung also nicht sichtbar sein und er würde vorerst auch noch keinen Zweck erfüllen. Aber dieser Schritt ist wichtig, weil der Webbrowser sonst nicht wissen kann, was er mit den Microdata anfangen soll, die in diesem Container auftauchen.

\subsubsection{Eigenschaften von Objekten}

Nehmen wir an, der Name der Person lautet \glqq{}Martin Schinken\grqq{}. Für unsere Microdata benötigen wir jetzt also eine Möglichkeit, um eine Eigenschaft \glqq{}Name\grqq{} zu programmieren und diese als Teil des Objekts einzuprogrammieren.\\

In HTML5 wird das wieder über ein Attribut eines Containers erledigt. Das Attribut lautet \verb|itemprop|\index{HTML!Attribute!itemprop} (kurz für the items property). Nun gibt es wieder eine Vielzahl an möglichen Arten von Eigenschaften, also müssen wir diese gleich festlegen.\\

Hinweis: Wenn Sie wie in diesem Fall erfahren, wofür ein \glqq{}Befehl\grqq{} einer Programmsprache steht (hier \verb|itemprop| für the items property), dann setzen Sie in einen Programm bitte nicht diese Langform (hier \glqq{}the items property\grqq{}) ein, denn nur der \glqq{}Befehl\grqq{} (hier \verb|itemprop|) ist ein gültiger Teil der Programmiersprache. Die Langform soll Ihnen lediglich als eine Eselsbrücke dienen.\\

\textbf{Aufgabe:}

\begin{itemize}
	\item Schlagen Sie nach, wie die itemprop heißt, die für den Namen einer Person verwendet wird.
\end{itemize}

Jetzt müssen wir nur noch einen Container innerhalb des \verb|<p>|-Containers programmieren, der das Attribut \verb|itemprop| mit dem Wert beinhaltet, den Sie gerade nachgeschlagen haben. \\

Der Quellcode sollte jetzt also so aussehen: (Für die drei Punkte setzen Sie bitte die von Ihnen gerade recherchierte \verb|itemprop| ein.)

\begin{verbatim}
	<p itemscope itemtype=http://schema.org/Person>
	<span itemprop=...>Martin Schinken</span>
	</p>
\end{verbatim}

\textbf{Aufgabe:}\\

Bei diesem Quellcode sind zwei Fehler enthalten. Der eine ist die fehlende \verb|itemprop|, die Sie nachtragen sollten. Den anderen kennen Sie schon etwas länger. Genauer gesagt sind in diesem Quellcode also nicht zwei Fehler enthalten, sondern vielmehr fehlen hier zwei Einträge. (Tipp: Wäre der Name Martin Holz oder Martin Hammer, dann wären es ebenfalls zwei Fehler. Beim Namen Martin Borowski dagegen würde der zweite Fehler nicht auftreten.)

\begin{itemize}
	\item Ergänzen Sie den Code so, dass die beiden Fehler bereinigt werden.
\end{itemize}

\subsubsection{Umfangreiche Microdata am Beispiel einer Person mit Adressangabe}

\textbf{Aufgabe:}\\

Auch das nachfolgende Codefragment ist lückenhaft. Recherchieren Sie, welche Attributbelegungen jeweils Sinn machen:

\begin{verbatim}
	<section itemscope itemtype=http://schema.org/Person>
	<h1>Kontakt</h1>
	<dl>
	<dt>Name</dt>
	<dd itemprop= ... >Ihr Name</dd>
	<dt>Position</dt>
	<dd>
	<span itemprop= ... >Student/in</span> an der
	<span itemprop= ... > HAW Hamburg</span>
	</dd>
	</dl>
	<div itemprop= ... itemscope itemtype= ... >
	<span itemprop= ... >Hamburger Str. 231</span>
	<span itemprop= ... >Hamburg</span>,
	<span itemprop= ... >22081</span>
	</div>
	<h1>Online bin ich aktiv bei:</h1>
	<ul>
	<li><a href=http://www.twitter.com/ihrTwitterAccount itemprop= ... >Twitter</a></li>
	<li><a href=http://www.blogger.com/ihrBlogAccount itemprop= ... >Webblog</a></li>
	</ul>
	</section>
\end{verbatim}

\subsection{Validator für Microdata}

Um zu prüfen, ob Ihre Microdata eindeutig programmiert sind, können Sie auf der folgenden Webanwendung einen Testbereich finden:\\

\verb|http://developers.google.com/structured-data|  \\

\textbf{Aufgabe:}\\

Prüfen Sie dort, ob Ihre Lösungen zu den beiden letzten Aufgaben valide sind.

\section{Zusammenfassung}

Sie wissen jetzt:

\begin{itemize}
	\item wie die Grundstruktur jeder Webanwendung aussieht,
	\item verstehen was Internationalisierung und Lokalisierung ist,
	\item wissen um die Bedeutung von meta-Containern,
	\item kennen die neuen Container header, footer, main, aside, usw.
	\item und wissen wie Sie Polyfills finden und nutzen können.
\end{itemize}

Sie wissen außerdem:

\begin{itemize}
	\item wie Sie Verbindungen zwischen Webanwendung programmieren können,
	\item wie Sie Nutzereingaben in HTML ermöglichen können
	\item und wie Sie multimediale Inhalte in die Webanwendung einbinden können.
\end{itemize}

Außerdem verstehen Sie, was das semantische Web ist und wie Sie mittels Microdata eine semantische Webanwendung programmieren können.\\

Was jetzt noch fehlt und leider nicht Teil dieses Kurses ist, ist die Entwicklung von interaktiven Oberflächen in HTML5 mit Hilfe von Canvas. Denn das programmieren Sie über JavaScript.\\

Im nächsten Kapitel folgt die zweite Hälfte des Kursteils, in dem sie die Entwicklung statischer Webanwendung kennen lernen: CSS, die Programmiersprache, mit der Sie die Gestaltung einer Webanwendung programmieren.