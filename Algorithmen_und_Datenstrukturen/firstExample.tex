\chapter{Eine erste Aufgabe: Highscore-Liste}

Stellen Sie sich vor, Sie wollen in einem Ihrer Programme eine Highscore-Liste programmieren, also eine Aufstellung der SpielerInnen, die ein Spiel gespielt haben und die nach dem erreichten Punktestand sortiert wird. Dann ist die wichtigste Frage nicht die, welchen Datentyp Sie für den Namen der einzelnen SpielerInnen wählen oder welchen Datentyp Sie für die Punkte wählen. Vielmehr ist die wichtigste Frage die, wie Sie die Sortierung so organisieren können, dass die Liste auch dann noch vollständig richtig sortiert ist, wenn in jeder Sekunde neue Einträge hinzukommen bzw. alte Einträge entfallen.\\

Sie fragen, warum da alte Einträge entfallen müssen? Ganz einfach: Stellen Sie sich vor, Spieler beenden ein Spiel alle drei oder fünf Minuten. Wenn nun nicht jeweils nur ein Ergebnis pro SpielerIn in der Liste auftaucht, eben das jeweils beste aller Spieldurchgänge, dann ist es kaum möglich, dass Spieler sich vergleichen. Es wird stets die Frage im Raum stehen, ob die SpielerInnen in der Liste doch noch irgendwo ein besseres Ergebnis geschafft haben. Und damit ist die Liste letztlich überflüssig.\\

Wenn Sie sich fragen, warum dieser Punkt so ausführlich besprochen wird, dann machen Sie sich bitte bewusst, dass Sie bei der Programmierung eben auch dieses Löschen direkt oder indirekt realisieren müssen; der Computer vergisst nicht einfach so, sondern dann und nur dann, wenn wir durch einen entsprechenden Programmteil sicherstellen, dass Daten entfernt werden.\\

Eine zweite wichtige Frage ist die, wie Sie den Teil der Liste anzeigen können, der jeweils für einzelne SpielerInnen interessant ist.\\

Reine Programmierer werden diese beiden Frage ignorieren und sich erst dann mit Ihr beschäftigen, wenn das Kind in den Brunnen gefallen ist, also dann, wenn die Spieler sich reihenweise im Forum zum Spiel darüber beklagen, dass die Highscoreliste \glqq{}voll buggy\grqq{} oder \glqq{}zu langsam\grqq{} ist. Und tatsächlich ist die Entwicklung einer \glqq{}guten\grqq{} Highscore-Liste eine ausgesprochen anspruchsvolle Aufgabe. Schauen wir uns also an, wie wir mit diesem Problem umgehen können, bzw. was es bedeutet, wenn wir die Sortierung auf unterschiedliche Weise angehen.\\

\textbf{Anm.:} Ein Ziel dieses Kurses besteht darin, dass Sie einige Standard-\\Algorithmen kennen, und dass Sie im Stande sind, zu bewerten, wie gut diese Algorithmen für ein bestimmtes Problem geeignet sind. Um das etwas anschaulicher zu gestalten werden Sie diese Algorithmen bzw. jeweils passende Datenstrukturen in Java programmieren.

\section{Vertiefung: Variablen in der Realität}

Die Überschrift mag etwas seltsam klingen: Sie haben Variablen bislang als etwas kennen gelernt, dass in einer Programmiersprache dazu dient, um Werte zu speichern. Also stellt sich nun die Frage, warum es hier einen Abschnitt zu Variablen \glqq{}in der Realität\grqq{} geben soll.\\

In diesem Abschnitt behandeln wir mehrere Aspekte, die in den Bereich der \textbf{Technischen Informatik}\index{Technische Informatik} gehören, da wir tatsächlich über die technischen Grundlagen von Computern reden, die für unseren Kurs relevant sind.\\

Tatsächlich ist das, was Sie als Variablen in einer Programmiersprache wie Java oder PHP kennen gelernt haben aber nur eine stark vereinfachte Sicht auf das, was tatsächlich im Computer passiert. Und ohne ein besseres Verständnis dafür, was dort tatsächlich passiert werden Sie nicht im Stande sein, Datenstrukturen zu verstehen. Damit wiederum werden Sie nicht im Stande sein, umfassend zu verstehen, warum die Beschäftigung mit Algorithmen und Datenstrukturen so essenziell ist.\\

Schauen wir uns dazu zunächst an, woraus ein Computer besteht. In anderen Worten: Schauen wir uns die \textbf{Computerarchitektur}\index{Computerarchitektur} an. Im Folgenden geht es nicht um die Konzepte des von-Neumann-Rechners oder der Harvard-Architektur, die sonst einen Einstieg in dieses Thema bietet. Vielmehr schauen wir uns Computerarchitektur vor dem Hintergrund an, wie Variablen dort tatsächlich vorliegen und was alles nötig ist, damit wir Sie so nutzen können, wie das in Programmiersprachen der Fall ist.\\

Grunsätzlich haben wir bei Computern (mindestens) einen Prozessor, (mindestens) einen Speicher und (mindestens) einen Weg, um Daten zwischen den beiden zu transportieren. Um es uns leicht zu machen werden wir im folgenden so tun, als wenn es von all diesen Dingen jeweils nur eines gäbe.\\

Der Speicher und der Prozessor sind bei heutigen Computern einzig im Stande, Binärwerte, also die zwei unterschiedliche Symbole zu verarbeiten. Die bezeichnen wir in der Informatik als 1 und 0. Was diese 1 und 0 in der realen Welt alles sein können ist Thema von Veranstaltungen zur Nachrichten- und Kommunikationstechnik. Wie in der Informatik üblich vereinfachen wir die Situation, indem wir so tun, als wenn es die 1 und die 0 als Zahl gäbe.\\

Als NutzerInnen von Computern sind wir es dagegen gewöhnt, dass Computer uns Bilder und Texte anzeigen sowie Musik spielen. Außerdem können wir mit ihnen diese drei Medien übertragen. Weiterhin können wir mit den unterschiedlichsten Geräte Computer bedienen. Da wären Touchscreens, Mäuse, Tastaturen, usw. In Programmieren 1 haben Sie gelernt, dass all das bereits durch die Benutzung von Variablen erreicht werden kann.\\

Wir müssen uns jetzt also ansehen, wie es möglich ist, von Einsen und Nullen zu Variablen zu kommen, um zu verstehen, was eine Programmiersprache leisten muss. Zum Teil werden diese Aufgaben von Betriebssystemen übernommen, zum Teil von Programmiersprachen. Die Grenze ist dabei nicht festgelegt und darum unterscheiden wir an dieser Stelle nicht, wo die Aufgaben gelöst werden.

\subsection{Speicher im Computer}

Damit wir Variablen nutzen können ist die erste Voraussetzung, dass wir \textbf{addressierbaren Speicher}\index{Speicher} nutzen können. Wie Sie wissen befindet sich in jedem Computer Speicher. Diesen können Sie sich vereinfacht als eine nahezu endlose Fläche mit Karopapier vorstellen: Jedes Kästchen enthält eine 1 oder eine 0. Wenn wir damit arbeiten wollen, dann müssen wir im Stande sein, jedes Kästchen bewusst anzusprechen. Denn sonst ist der Speicher für uns wie ein Telefon: Wenn wir keine Möglichkeit haben, andere Personen bewusst auszuwählen, dann nützt uns das Telefon nichts. Beim Telefonieren nutzen wir dafür Telefonnummern: Zahlen, denen jeweils genau ein bestimmter Anschluss zugeordnet ist.\\

Genau dasselbe brauchen wir auch beim Computerspeicher, nur dass wir hier nicht von Telefonnummern, sondern von \textbf{Addressen}\index{Speicher!Addresse} reden. Und genau wie eine Telefonnummer jedem Anschluss zugeordnet werden muss, muss auch beim Speicher eines Computers jedem Bereich eine Addresse zugeordnet werden. Das ist eine der Aufgaben, die nie von der Programmiersprache, sondern immer vom Betriebssytem übernommen wird.\\

Bei vielen Rechnern wird der Speicher in Einheiten von 8 Bit Länge einzuteilen. Bei vielen, aber längst nicht bei allen, also seien Sie auf Systeme mit einer anderen Speichereinteilung vorbereitet.\\

Das bedeutet, dass jede Adresse auf einen Speicherbereich verweist, in dem wir eine Zahl von 0 bis 255 speichern können. Anders ausgedrückt (und das ist wichtig), können wir mit einem solchen Speicherbereich 256 verschiedene Symbole \glqq{}speichern\grqq{}. Wir können in solch einem Speicherbereich auch die Belegung von 8 Leitungen  speichern, über die unser Computer Daten empfängt oder sendet.\\

Diese beiden unterschiedlichen Interpretationen dienen dazu, dass Sie verstehen, dass ein 8-Bit-Speicher nicht ausschließlich dafür genutzt werden kann, um die Zahlen von 0 bis 256 speichern zu können; denn wofür die einzelnen Ziffern und Zahlen stehen, darüber sagt der gespeicherte Wert nichts aus. Wichtig ist auch, dass Sie sich vergegenwärtigen, dass diese Einteilung des Speichers in 8-Bit-Einheiten eine willkürliche Festlegung ist und dass es möglich ist, mehr oder weniger Bit pro Speicheradresse zusammenfassen. Es ist dabei weitgehend irrelevant, was für ein Prozessor im Computer steckt.\\

Im Gegensatz dazu hat Speicher immer auch eine Zugriffsgeschwindigkeit, die durch seine Bauweise und Spezifikation festgelegt ist. Hierauf können wir im Regelfall nicht zugreifen, sondern müssen mit der Geschwindigkeit zurechtkommen, für die der Speicher konfiguriert ist. Eine höhere Geschwindigkeit als die Lichtgeschwindigkeit ist aber nicht möglich. Als grobes Augenmaß können Sie sagen, dass die 4 GHz, also \(4 \cdot 10^9\) Operationen pro Sekunde, die ein Prozessor ausführen kann die Obergrenze für jede Art der Datenübertragung bildet. Speicher in aktuellen Desktoprechnern arbeitet üblicherweise mit weniger als 300 MHz, also werden maximal \(3 \cdot 10^8\)-mal pro Sekunde Daten zwischen Speicher und Prozessor ausgetauscht.\\

\emph{Einige von Ihnen werden jetzt vielleicht protestieren, weil in Ihrem Computer Speicher eingebaut ist, der mit 3 GHz arbeitet, aber das basiert auf einem Missverständnis: Die tatsächliche Taktung von Speicher kann z.B. 200 MHz sein. Daraus ergeben sich \glqq{}3 GHz\grqq{} über einen Rechentrick: Vereinfacht ausgedrückt werden bei jeder Datenübertragung 15 Byte übertragen, anstelle von nur einem. \(15 \cdot 200\) MHz = 3 GHZ. Das sind aber eben keine realen 3 GHz und es ist auch nicht der volle Geschwindigkeitsgewinn, weil eben nicht 15 Byte übertragen werden, die für den Programmablauf benötigt werden, sondern es wird in diesem Fall ein Byte übertragen, das benötigt wird und 14 Byte, die im Speicher darauf folgen. Es ist richtig, dass benachbarter Speicher häufig gemeinsam benutzt wird und deshalb ergibt ein solcher Multiplikator auch durchaus Sinn: Dieser Multiplikator erhöht tatsächlich die Menge der übertragenen Daten pro Sekunde, aber nicht alle dieser Daten werden tatsächlich benötigt. Viel wichtiger ist hier also der Takt, mit dem der Speicher arbeitet, denn das erste Byte, das in einem Takt übertragen wird wird auch immer benötigt.}\\

\textbf{Zusammenfassung:}\\

Sie haben jetzt ein Grundverständnis dafür, was Computerspeicher ist: Eine geordnete Ansammlung von direkt ansprechbaren Bereichen, in denen wir Binärwerte einer gewissen Größe speichern können.

\subsection{Datenübertragung}

Aus der Sicht der Informatik sind Wege zur Datenübertragung gewissermaßen eine Black Box, von der wir nur wissen, dass wir in einem bestimmten Zeitraum eine bestimmte Menge an Daten maximal darüber übertragen können. Die Nachrichten- und Kommunikationstechnik ist dann der wissenschaftliche Bereich, in dem die Techniken und Technologien entwickelt werden, die uns die Datenübertragung überhaupt ermöglicht. Sie untersucht auch, wie und wie gut Fehler bei der Datenübertragung automatisch korrigiert oder zumindest erkannt werden können.\\

Für uns ist in diesem Kurs einzig die resultierende Geschwindigkeit relevant. Sie werden allerdings feststellen, dass wir auch diese nicht konkret untersuchen, da wir uns auf die Geschwindigkeitsunterschiede von unterschiedlichen Algorithmen konzentrieren werden, die die gleiche Aufgabe erfüllen. Und das das Verhältnis der beiden zueinander nicht von der Geschwindigkeit der Datenübertragung auf unterschiedlichen Systemen abhängt, ist eben diese Geschwindigkeit im Rahmen dieses Kurses irrelevant.

\subsection{Prozessoren}

Damit kommen wir zu dem Teil eines Computers, der die eigentliche Verarbeitung leistet. Ähnlich wie die Datenübertragung spielt der Prozessor selbst in diesem Kurs nur eine kleine Rolle: Bezüglich der Geschwindigkeit gilt dasselbe wie für die Datenübertragung. Allerdings werden wir gelegentlich auf Parallelprozessoren eingehen.\\

Der Vollständigkeit halber sei hier noch angemerkt, was es mit Prozessoren wie einem 64-Bit-Prozessor auf sich hat: Die \textbf{Bittigkeit} eines Prozessors (in diesem Fall 64) sagt aus, wie viele Bit der Prozessor gleichzeitig verarbeiten kann. Sie gibt damit auch an, wie viel Speicher ein Prozessor maximal verwalten kann: Ein 8-Bit-Prozessor kann maximal \(2^8\), also 256 Bereiche im Speicher addressieren, weil er eben nur bis zu 256 Zahlen kennt. Das ist auch der Hauptgrund, aus dem vor einigen Jahren 64-Bit-Prozessoren auf den Markt kamen: Ein 32-Bit-Prozessor kann maximal 4 Mrd. Einheiten Speicher verwalten (bei einem Byte pro Einheit ergibt das die Obergrenze von 4 GB).\\

Rechnen Sie es ruhig nach: Wir haben also mit 64-Bit-Prozessoren die Möglichkeit, mehr Speicherbereiche direkt anzusprechen als das Universum Atome hat. Damit können heutige Prozessoren genug Speicher nutzen, um jedes lösbare Problem tatsächlich zu bearbeiten.

\subsection{Datentypen und Computerspeicher}

Aus Sprachen wie Java kennen Sie statische Datentypen. Bislang wissen Sie lediglich, dass es sich dabei um eine Festlegung handelt, was für eine Art von Wert in einer Variablen gespeichert werden kann. So haben Sie den Datentyp int kennen gelernt, mit dem Sie Zahlen speichern können, die zwischen 0 und \(2^{32}-1\) Bit groß sind. Mit dem Wissen der vorigen Abschnitte können Sie jetzt schlussfolgern, dass diese Zahlen (vermutlich) 4 Einheiten Speicher belegen. Hier hätten wir also einen Datentyp, der jeder Zahl zur Basis 10 einen Gegenwert als 2er Komplement im Speicher zuordnet.\\

Und genau das ist es, was \textbf{Datentypen} tun: Sie \textbf{legen fest, wie ein Binärwert im Speicher interpretiert wird.}\\

Schauen wir uns das einmal für char-Variablen an, also für Variablen an, die z.B. einen Buchstaben speichern können. Zwar können wir willkürlich eine Zuordnung (Interpretation) eines Binärwerts im Speicher zu einem Buchstaben festlegen, aber das wäre problematisch, weil diese Zuordnung eben unsere willkürliche Festlegung wäre, anstatt das wir einen international gültigen Standard hätten. Wir hätten somit eine (wenn auch sehr schwache) Verschlüsselung erzeugt. Wenn Sie wissen wollen, warum diese Verschlüsselung sehr schwach ist, dann freuen Sie sich schon einmal auf die Veranstaltung \textbf{Kryptographie}, denn dort werden Sie die Antwort auf diese Frage kennen lernen.\\

Hier wie auch an anderen Stellen nutzen wir wieder Ergebnisse aus der Nachrichtentechnik: In der Nachrichtentechnik werden auch Standards entwickelt, wie Binärzahlen z.B. als Buchstaben interpretiert werden können. Wenn wir eine Tabelle haben, die festlegt, welche Binärzahl welchem Buchstaben (oder anderen Symbol) entspricht, dann wird das als \textbf{Codierung}\index{Codierung} bezeichnet. Codierung umfasst allerdings noch wesentlich mehr. Aber darüber hören Sie etwas in der Veranstaltung \textbf{Kommunikationstechnik}\index{Kommunikationstechnik}.\\

Die beste Codierung, die Sie zurzeit wie Texte in Programmen verwenden können ist die sogenannte UTF-Codierung. Sie ist deshalb am besten geeignet, weil sie entwickelt wurde, damit die Symbole jeder Sprache der Welt eindeutig einem Binärwert zugeordnet sind. Wenn Sie also einen Datentyp verwenden, der UTF umsetzt, dann können Sie jedes Symbol jeder Sprache weltweit direkt in Ihrem Programm verwenden. Allerdings hat UTF gegenüber Codierungen wie ASCII einen Nachteil: Sie benötigt bis zu 32 Bit (4 Byte) pro Zeichen. Sollten Sie also einen Rechner mit wenigen KB Speicher nutzen, könnte es nötig sein, auf UTF zu verzichten.\\

Das bringt uns zum zweiten Detail bezüglich Datentypen in der Realität: \textbf{Ein Datentyp} legt nämlich nicht nur fest, wie ein Binärwert aus dem Speicher zu interpretieren ist, sondern er \textbf{legt gleichzeitig fest, wie viel Speicher für eine Variable zu reservieren ist}: Eine Programmiersprache, in der eine char-Variable die Codierung ASCII umsetzt reserviert für jede dieser Variablen 8 Bit Speicher. Eine Programmiersprache, in der eine char-Variable dagegen die Codierung UTF umsetzt, reserviert für jede dieser Variablen 32 Bit Speicher.

\subsection{Vom Datentyp zur Datenstruktur}

Und damit können Sie auch umfassend verstehen, was der Unterschied zwischen einem Datentyp und einer Datenstruktur ist: Ein Datentyp sagt immer aus, wie viel Speicher eine Variable belegt. Und dieser Speicherbedarf ist für alle Variablen eines Datentyps identisch. Also können Sie jetzt verstehen, warum ein String kein Datentyp ist.\\

\textbf{Aufgabe:}\\

Begründen Sie in eigenen Worten, warum ein String kein Datentyp ist.

\subsection{Zusammenfassung und Abschluss}

Beim Programmieren erzeugen, nutzen und ändern wir Variablen, die einen Datentyp und einen Wert haben.\\

In der Realität haben wir einen \textbf{Bezeichner} (den Namen, den wir der Variablen geben), also etwas, das bereits eine Datenstruktur vom Typ String ist.\\

\emph{Mit ein wenig Denkschmalz können Sie sich jetzt erklären, warum es Programmiersprachen gibt, bei denen nur die ersten acht Buchstaben eines Bezeichners tatsächlich verwendet werden können. Richtig gelesen: Die übrigen Zeichen des Bezeichners werden von diesen Sprachen ignoriert. Die Variablen abcdefgah und abcdefgahcde sind in solchen Sprachen also identisch.}\\

Dieser Bezeichner verweist auf eine (!) \textbf{Adresse} im Speicher. Was Sie noch nicht wissen: Dieser Verweis, wird als \textbf{Pointer} bezeichnet. Es gibt Programmiersprachen, in denen Sie den Pointer ähnlich dem Wert der Variablen selbst programmieren können. Das wird als \textbf{Pointerarithmetik} bezeichnet.\\

\emph{Viele Informatikstudierende scheitern an der Pointerarithmetik in C, weil Sie nicht begreifen bzw. weil ihnen nicht gesagt wurde, das der Pointer schlicht die Adresse ist, auf die eine Variable verweist.}\\

Der \textbf{Datentyp} legt wiederum zwei Dinge fest:\\

(1) Wie groß der Speicherbedarf der Variablen ist, also wie viele Einheiten Speicher für die Variable reserviert werden, auf die die Variable verweist. In anderen Worten: Gehören nachfolgende Adressen zur Variable und wenn ja, wie viele sind es.\\

(2) Wie der Binärwert zu interpretieren ist, der in dem Speicherbereich gespeichert ist, der der Variablen zugeordnet ist.\\

Es ist wichtig, dass Sie diese Vertiefung grundsätzlich verstanden haben, da sie die Grundlage für alles darstellt, was wir in diesem Kurs besprechen werden. Das beginnt bereits bei der Besprechung von Arrays, bzw. bei der Antwort auf die Frage, warum das, was in PHP als Array bezeichnet wird keine Datenstruktur namens Array ist.

\section{Highscore-Liste und Array}

Ein \textbf{Array}\index{Datenstruktur!Array}\index{Array} ist ein Bereich im Speicher, der in gleichgroße Teile unterteilt ist. Jedes dieser Teile ist genau so groß, dass eine Variable eines bestimmten Datentyps darin gespeichert werden kann.\\

Es gibt aber auch mehrdimensionale Arrays. Wenn wir z.B. von einem fünf-dimensionalen Array sprechen, dann bedeutet das, dass jeder der genannten Teile so groß ist, dass fünf Variablen darin gespeichert werden können. Ob diese fünf Variablen alle den gleichen Datentyp haben müssen oder ob jede davon einen individuellen Datentypen haben darf, das hängt von der Programmiersprache ab. Aber grundsätzlich gilt, dass alle Variablen in einer Dimension eines Arrays den gleichen Datentyp haben müssen. Analog zum fünf-dimensionalen Array können Sie sich andere mehr-dimensionale Arrays veranschaulichen.\\

Dementsprechend können wir bei einer dynamisch typisierten Sprache wie PHP gar keine Datenstruktur wie ein Array haben. In \textbf{dynamisch typisierten Sprachen}\index{Array!dynamisch typisiert} werden wir aber dennoch häufig Datenstrukturen finden, die als Array bezeichnet werden. Der Grund ist simpel: Da die Programmierung dieser Datenstrukturen genauso durchgeführt wird, wie das bei einem Array der Fall ist, wirkt es für reine ProgrammiererInnen so, als wenn es sich tatsächlich um Arrays handeln würde. Im Hintergrund ist aber eine ganz andere Datenstruktur am Werk, mit den jeweiligen Vor- und Nachteilen.\\

Das ist ein weiterer Punkt, in dem sich InformatikerInnen und ProgrammiererInnen unterscheiden: InformatikerInnen lernen zuerst, was die Datenstruktur Array ist, während ProgrammiererInnen zuerst etwas kennen lernen, dass in einer Programmiersprache als Array bezeichnet wird. Da die \glqq{}Arrays\grqq{} in unterschiedlichen Sprachen aber teilweise nichts mit der Datenstruktur Array gemein haben, führt der Einstieg von reinen ProgrammiererInnen häufig zu Problemen, wenn sie neue Programmiersprachen erlernen wollen: Kaum eine Einführung in eine Programmiersprache geht auf die Unterschiede zwischen den allgemein definierten Datenstrukturen und der konkreten Umsetzung in der jeweiligen Sprache ein. Wenn Sie beispielsweise Java gelernt haben, dann werden Sie sehr aufpassen müssen, wenn wir in diesem Kurs über Hash-basierte Datenstrukturen sprechen.\\

Um den Einstieg zu erleichtern werden wir in den nächsten Abschnitten so tun, als wenn es nur die Datenstruktur Array gäbe. Später lernen Sie dann Datenstrukturen kennen, die sich sehr von Arrays unterscheiden.\\

\textbf{Aufgabe:}

\begin{itemize}
	\item Erklären Sie in eigenen Worten, warum es in dynamisch typisierten Sprachen kein \glqq{}echtes\grqq{} Array geben kann.
	
	\textbf{Tipp:} Die Antwort steht nicht im vorigen Absatz. Um diese Aufgabe zu lösen müssen Sie den Unterschied zwischen statischer und dynamischer Typisierung verstanden haben und sich bewusst machen, was während des Ablaufs eines Programms im Speicher passieren kann.
\end{itemize}

Nehmen wir an, wir haben ein zweidimensionales Array, in dem die ersten Ergebnisse gespeichert, aber noch nicht sortiert sind:\\

\begin{tabular}{l l}
	Horst & 100 \\
	Susi & 260 \\
	Max & 10 \\
	Knock Knock & 500 \\
	Super Richie & 2321\\
	Queen Alice & 91243 \\
	Zombie Maniac & 2212 \\
	Cammy-Ka-Tse & 90 \\
	Say cheeeeeeeeze & 1203 \\
\end{tabular}\\

Damit daraus eine wunschgemäße Highscore-Liste wird, müssen wir nun etwas entwickeln, das als \textbf{Sortieralgorithmus}\index{Algorithmus!Sortieralg.} bezeichnet wird.\\

Die Bezeichnung folgt dabei direkt aus der Aufgabe eines Algorithmus: Ein Sortieralgorithmus heißt Sortieralgorithmus, weil er ein Algorithmus ist, der die Elemente einer Menge (hier die Einträge eines Arrays) sortiert.\\

\emph{Und nun raten Sie mal, was ein Suchalgorithmus ist.}

